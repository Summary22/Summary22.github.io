<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Objective-C学习笔记]]></title>
    <url>%2F2018%2F03%2F26%2FObjective-C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Objective-C笔记 .m文件代表的是message，指的是OC的一种主要特性。 #import是让编译器在头文件中查询定义 框架是一种聚集在一个单元的部件集合，包含头文件，库，图像，声音文件等，Foundation框架的头文件Foundation.h包含一百多个文件，一旦使用#import&lt;Foundation/Foundation.h&gt;， 那么将会获得全部集合。 argc是命令行总的参数个数,argv[]是argc个参数，其中第0个参数是程序的全名，以后的参数命令行后面跟的用户输入的参数，char *argv[]是一个字符数组,其大小是int argc,主要用于命令行参数argv[]参数，数组里每个元素代表一个参数 特别的.h文件和.m文件build之前一定要将.h文件右键properties-&gt;advance下的compiler…改为objc 创建类 123456789101112131415161718192021222324252627282930313233343536//头文件Fraction.h#import&lt;Foundation/Foundation.h&gt;@interface Fraction:NSObject&#123; int numerator; int denominator;//成员变量，这里是private的字段，数据存储在字段中，修改字段才修改数据。封装起来，保证数据安全。&#125;-(void) print;-(void) setNumerator:(int) n;-(void) setDenominator:(int) d;-(int) numerator;-(int) denominator;//这里是属性，有get和set方法//.m文件#import&lt;stdio.h&gt;#import&quot;Fraction.h&quot;@implementation Fraction-(void) print&#123; printf(&quot;%i/%i&quot;,numerator,denominator);&#125;-(void) setNumeration:(int) n&#123; numerator=n;&#125;...-(int) denominator&#123; return denominator;//属性中get方法，这样上面print可以访问成员变量&#125;@end//main函数中使用//头文件中要包含：Fraction.hFraction *frac=[[Fraction alloc] init];[frac print];[frac setNumeration:1]//多个参数,-(void)setNumerator:(int) n andDeminator:(int) d; 构造子，先看一下构造函数和析构函数 的区别。1234567891011121314151617//.h里面的声明-(Fraction*) initWithNumerator:(int)n denomination:(int)d//.m具体实现方法-(Fraction*) initWithNumerator:(int)n denomination:(int)d&#123; self=[super init]; if(self) &#123; [self setNumerator:n andDenomitor:d]; &#125; return self;&#125;//if(self)等同if(self!=nil),nil等同于NULL，//main函数中实现Fraction *frac3 = [[Fraction alloc] initWithNumerator: 3 denominator: 10];printf( &quot;Fraction 3 is: &quot; );[frac3 print];printf( &quot;\n&quot; ); self 是指指向自己的指针 Class level access 前面带有减号(-) 的方法为实例方法，必须使用类的实例才可以调用的。对应的有+号， 代表是类的静态方法，不需要实例化即可调用。 类方法用类名访问，实例方法用示例名访问。静态方法可以直接调用,实例方法要先成生实例,通过实例调用方法，静态速度很快，但是多了会占内存。静态内存是连续的,因为是在程序开始时就生成了,而实例申请的是离散的空间,所以当然没有静态方法快，而且静态内存是有限制的，太多了程序会启动不了。 类方法可以计算一个实体被instance几次，还可以共享数据，它不需要访问或者修改某个实例的成员变量。类方法一般用于实现一些工具方法，比如对某个对象进行扩展，或者实现单例。如果需要访问或者修改某个实例的成员变量时，将该方法定义成实例方法。如果需要访问或者修改某个实例的成员变量时，将该方法定义成实例方法。 插入一点:windows要通过各种各样的句柄来标识诸如应用程序实例，窗口，图标菜单等对象。句柄的实际值对程序来讲无光紧要，这个值是用来引用相应对象的。句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下搭建OC环境]]></title>
    <url>%2F2018%2F03%2F26%2FWindows%E4%B8%8B%E6%90%AD%E5%BB%BAOC%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装Objective-C编译器需安装文件地址：链接 ，密码是：lm8y 先安装OC的编译器，这里使用的是GNUstep，安装次序为：gnustep-msys-system、gnustep-core、gnustep-devel 接着安装IDE，选择codeblocks作为IDE 配置开发环境 先进入setting-&gt;Compiler anddebugger…,进去之后选择GUN GCC Compiler，按copy按钮，将其重新命名为GUNstep MinGW Compiler，如下图： 这里一定要将selected compiler选择到GUNstep MinGW Compiler，然后点击set as default。勾选如图的两个选项。 然后在compiler flags旁边的other compiler options里面添加这句话：-fconstant-string-class=NSConstantString -std=c99 在linker setting中添加两个链接，分别链接到libgnustep-base.dll.a和libobjc.dll.a，我的GUNstep是安装在D盘，所以路径依次是：D:\GNUstep\GNUstep\System\Library\Libraries\libgnustep-base.dll.a 和D:\GNUstep\GNUstep\System\Library\Libraries\libobjc.dll.a 如下图： 指定搜索目录，Search directories，这里有两处需要指定，第一是compiler，将其设置为D:\GNUstep\GNUstep\System\Library\Headers 第二处是linker，将其设置为D:\GNUstep\GNUstep\System\Library\Libraries 这两个不能写为同一个路径。如下图： 添加Objective-C文件支持类型 进入Settings-&gt;Environment…，选择Files extension handling 添加*.m。如图： 然后新建一个项目，在project-&gt;project tree-&gt;categories…下面将*.m添加到source下，一定要注意前面使用; 分号分开的，如下图： 进入Settings-&gt;Editor…，选择Syntaxhighlighting，点击Filemasks….按钮，在弹出框尾部添加*.m 到文件类型。如图： 然后点击Keywords…按钮 (紧靠Filemasks…按钮) 添加下面Objective-C的关键字到EditKeywords列表中。如图： @interface @implementation @end @class @selector @protocol @public @protected @private id BOOL YES NO SEL nil NULL self 这就大体完成了。 测试部分 测试代码如下： 123456789101112131415#import &lt;Foundation/Foundation.h&gt;int main (int argc, const char *argv[])&#123; NSAutoreleasePool *pool =[[NSAutoreleasePool alloc] init]; NSLog(@&quot;%@&quot;,@&quot;hello world&quot;); [pool drain]; return 0;&#125; 测试之前要在工程目录下新建一个.m文件，然后在编译器中右键这个文件，选择两个选项，如下图： #一点补充 关于代码高亮：在setting-&gt;editor里面，选择Syntax highlighting，然后选择objective c，点击filemasks…然后添加*.m，注意，后面加上，号,如下图：]]></content>
      <categories>
        <category>Stall IDE</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Windows</tag>
        <tag>GNUstep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一点makedown]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0-makedown%2F</url>
    <content type="text"><![CDATA[先写一点自己可能用得上的语法 有几个#号就是几级标题 一级二级三级四级 这是&gt;加空格 两个&gt;加空格 一个号加空格表示强调，可以在句中表示强调不过要以什么符号开始，就以什么结束，例子这个是星号*，如果回车还是一样的格式，不想这样要这个格式，那就再回车一下 回车再*号就会是空心小圆圈 一个-减号也是一个小黑点这样 像这样-–，***变成一个分隔符 链接有两种形式： 行内式：链接可以用[]加上()这样来书写，[]中间写链接内容，()中间写链接地址 ​ 我博客链接 参考式：两个[]连起来 例子:我的博客 &lt;noblestaspiration.net&gt; 自动链接 三个`这个符号是代码区，紧跟在三个符号后面的是语言类型，可以写Python或者C啊这些 1234567#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;111111&lt;&lt;endl; return 0;&#125; 两个``中间写的内容会变成其他颜色，但是第一个符号要加上空格 这就是其他颜色 插入图片是![]（）其中[]中填的是图片名称，后面写的是路径加上图片的名称，名称一定要加上类型，比如.jpg什么的，下面插一张图片 这里是内容 一对&lt;&gt;里面写blockquote class=”blockquote-center”这是搞一个像留言板下面那样的一个区域然后后面再加上一对&lt;&gt;里面写/blockquote这样就行了 另外\反斜杠可以帮助插其他符号，下面的就是前面已经加上反斜杠了 + ` * _ {} [] () # + - . ! 多级列表： 这是第一级 在上一行回车再回车之后tab再-加上空格]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>makedown</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python常用模块集锦]]></title>
    <url>%2F2018%2F03%2F12%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[Python常用模块集锦 常用模块主要分为以下几类（缺失的后续再补充）： 时间转换 时间计算 序列化和反序列化：json，pickle 编解码：unicode，base64 加解密：md5，sha1，hmac_sha1，aes 常见装饰器： 计算执行时间装饰器 缓存装饰器 错误重试装饰器 延迟装饰器 尾递归优化装饰器 ini配置文件读取 代码整合如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308#!/usr/bin/env python# -*- coding: utf-8 -*-"""Created on 9/21/17 1:46 PM@author: Chen Liang@function: python常用模块集锦，util.py"""import timeimport datetimeimport ConfigParserimport astimport sysimport jsonimport pickleimport base64import hashlibfrom Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexfrom functools import wrapsBEFORE = 1LATER = 2class CommonUtil(object): """Python通用单元：不好归类但常用的方法此处添加""" passclass TimeTransferUtil(object): """时间相关的常见转换方法""" class TimeUtil(object): """时间相关的常见计算方法""" @staticmethod def str_to_date(): passclass SerializeUtil(object): """序列化和反序列化：json, pickle""" @staticmethod def json_loads(json_str, encoding=None): try: obj = json.loads(s=json_str, encoding=encoding) return True, obj except ValueError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def json_dumps(obj): try: json_str = json.dumps(obj=obj) return True, json_str except TypeError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def pickle_loads(pickle_str): try: obj = pickle.loads(pickle_str) return True, obj except IndexError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def pickle_dumps(obj): try: pickle_str = pickle.dumps(obj) return True, pickle_str except Exception as e: return False, str(e)class CodecUtil(object): """编解码相关常见方法：base64 unicode""" @staticmethod def base64_encode(data): try: return True, base64.b64encode(data) except TypeError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def base64_decode(encoded_data): try: return True, base64.b64decode(encoded_data) except TypeError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def to_unicode(s, encoding='utf-8'): return s if isinstance(s, unicode) else unicode(s, encoding) @staticmethod def unicode_to(unicode_s, encoding='utf-8'): return unicode_s.encode(encoding)class CryptoUtil(object): """加解密相关常见方法： md5 aes""" @staticmethod def md5(str_object): """md5""" m = hashlib.md5() m.update(str_object) return m.hexdigest() @staticmethod def aes_encrypt(s, key, salt, mode=AES.MODE_CBC): """ aes加密 :param s: 待加密字符串 :param key: 密钥 :param salt: 盐, 16bit eg. b'0000000101000000' :param mode: AES模式 :return: 加密后的字符串 """ cipher = AES.new(hashlib.md5(key).hexdigest(), mode, salt) n_text = s + ('\0' * (16 - (len(s) % 16))) return b2a_hex(cipher.encrypt(n_text)) @staticmethod def aes_decrypt(s, key, salt, mode=AES.MODE_CBC): """ aes解密 :param s: 待解密字符串 :param key: 密钥 :param salt: 盐, 16bit eg. b'0000000101000000' :param mode: AES模式 :return: 解密后的字符串 """ cipher = AES.new(hashlib.md5(key).hexdigest(), mode, salt) return cipher.decrypt(a2b_hex(s)).rstrip('\0')class TailRecurseException: """尾递归异常""" def __init__(self, args, kwargs): self.args = args self.kwargs = kwargsclass DecoratorUtil(object): """常见装饰器： 执行时间timeit，缓存cache，错误重试retry""" __cache_dict = &#123;&#125; @staticmethod def timeit(fn): """计算执行时间""" @wraps(fn) def wrap(*args, **kwargs): start = time.time() ret = fn(*args, **kwargs) end = time.time() print "@timeit: &#123;0&#125; tasks, &#123;1&#125; secs".format(fn.__name__, str(end - start)) return ret return wrap @staticmethod def __is_expired(entry, duration): """是否过期""" if duration == -1: return False return time.time() - entry['time'] &gt; duration @staticmethod def __compute_key(fn, args, kw): """序列化并求其哈希值""" key = pickle.dumps((fn.__name__, args, kw)) return hashlib.sha1(key).hexdigest() @classmethod def cache(cls, expired_time=-1): """ 缓存 :param expired_time: 过期时间，-1 表示不过期 :return: 返回缓存的结果或者计算的结果 """ def _cache(fn): @wraps(fn) def wrap(*args, **kwargs): key = cls.__compute_key(fn, args, kwargs) if key in cls.__cache_dict: if cls.__is_expired(cls.__cache_dict[key], expired_time) is False: return cls.__cache_dict[key]['value'] ret = fn(*args, **kwargs) cls.__cache_dict[key] = &#123; 'value': ret, 'time': time.time() &#125; return ret return wrap return _cache @staticmethod def retry(exceptions, retry_times=3, time_pause=3, time_offset=1): """ 错误重试 :param exceptions: 单个异常比如ValueError, 或者tuple,元组元素是异常，比如(ValueError, TypeError) :param retry_times: 重试次数 :param time_pause: 初始暂停时间 :param time_offset: 暂停时间的偏移倍数，默认不偏移 :return: 返回成功的值，或者重拾次数结束时抛出异常 """ def _retry(fn): @wraps(fn) def wrap(*args, **kwargs): retry_times_tmp, time_pause_tmp = retry_times, time_pause while retry_times_tmp &gt; 1: try: return fn(*args, **kwargs) except exceptions: time.sleep(time_pause_tmp) retry_times_tmp -= 1 time_pause_tmp *= time_offset return fn(*args, **kwargs) return wrap return _retry @staticmethod def delay(delay_time=3, mode=BEFORE): """ 延迟装饰器，支持在函数执行之前和之后加延时，如果想在前后同时加，可以使用两次装饰。 time.sleep只会阻塞当前线程不会阻塞整个进程，其它线程不受影响 :param delay_time: 延迟时间，是float类型 :param mode: 模式，指定是在函数执行之前加延时还是在执行之后加，值为BEFORE(1)或者LATER(2) :return: """ def _delay(fn): @wraps(fn) def wrap(*args, **kwargs): if mode == BEFORE: time.sleep(delay_time) ret = fn(*args, **kwargs) if mode == LATER: time.sleep(delay_time) return ret return wrap return _delay @staticmethod def tail_call_optimized(fn): """尾递归优化装饰器，如果被装饰函数不是尾递归函数则会报错""" @wraps(fn) def wrap(*args, **kwargs): f = sys._getframe() if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code: raise TailRecurseException(args, kwargs) else: while True: try: return fn(*args, **kwargs) except TailRecurseException as e: args = e.args kwargs = e.kwargs return wrapclass IniConfigParserUtil(object): """ini配置文件读取""" def __init__(self, *file_names): """ init :param file_names: 包含多个元素的可迭代对象 """ self.config = ConfigParser.ConfigParser() for file_name in file_names: try: self.config.readfp(open(file_name, 'rb')) break except IOError: continue else: sys.exit('All files have failed to read') def get_string(self, section, option): return self.config.get(section, option) def get_int(self, section, option): return self.config.getint(section, option) def get_float(self, section, option): return self.config.getfloat(section, option) def get_boolean(self, section, option): return self.config.getboolean(section, option) def get_list(self, section, option): return ast.literal_eval(self.config.get(section, option)) def get_dict(self, section, option): return ast.literal_eval(self.config.get(section, option)) 缺失部分后续待添加，记得填坑。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
