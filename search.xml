<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MouseLight]]></title>
    <url>%2F2018%2F08%2F22%2FMouseLight%2F</url>
    <content type="text"><![CDATA[MouseLight：​ MouseLight是比较强大的软件，如果觉得这个软件有用，请购买正版，发布这个纯属娱乐。 ##大致分析 ##过程 ​ 安装好MouseLight（下载地址：https://pan.baidu.com/s/1zB8MJiqBxNc46MbKUtFluQ），然后运行起来，切到Misc目录下，发现有一栏需要输入注册码，有一栏写着只能使用30天。在输入注册码一栏中随便输入一些字符，然后点击Activate，会出现下图所示的错误 ​ 改写系统时间为30天之后，程序不能运行，如下图 ​ 使用OD打开mouselight，等待运行之后右键选择中文搜索引擎，选择搜索ASC码 ​ 参照上面错误信息，搜索unexplainable，结果如下图： ​ 双击以上字符，进入主程序区，上下查看，发现有很多种情况，会返回不同的情况，如下图所示，会有很多种返回的情况，不一一列举，下图中可以看到success字样，照常理，只要跳转的地方跳转到这里就会直接破解成功。向上翻查函数的起始地址，00404510为起始地址。 ​ 使用IDA打开程序，上面查看程序其实地址为00404510 ​ 按下F5反汇编其代码发现不能成功，这段是主程序，只能一步步单步调试，继续使用OD调试，从上往下调试，单步到00404696时，没有发生跳转直接进入到错误显示的界面，所以往上一条指令查看 Cmpdword ptr[0x413030], -0x7 ​ 发现每一条显示在界面的信息都有和dword ptr[0x413030]这个数据比较的语句，那么直接在堆栈区查找这个地址，然后F8单步调试下来看在哪一个函数里面，堆栈的值发生变化，如下图： ​ 当单步调试到如下图所示的地址时，堆栈信息发生变话，此时使用IDA查看函数功能发现函数有很多判断，根据不同返回值跳转到不同结果，下图所示： ​ 调试至此函数时堆栈信息发生变化 ​ 使用IDA查看函数代码： ​ 可以看到，只要返回值为1，最后结果就会显示成功，结合IDA的代码，单步调试OD，一边调试一边看IDA的代码，这样可以清楚的看到汇编的指令运行到哪一步，改完之后运行的结果如下图所示 ​ 提示上说需要重新启动程序，但是此时动态调试重新运行程序之前修改的内容会被覆盖为原来指令，所以这里将程序保存下来然后命名为MouseLight1重新运行，发现会跳出这个提示成功的界面但是并没有激活成功，仔细查看之前代码，发现时利用注册表信息来计算的返回值，那么程序中一定存在很关键的判断没有找到，这时候只能通过OD从程序开始调试，并且之前注意力一直在激活的字眼上，上面剩余30天的界面没有去管。此时单步调试 到如下函数时进入到了比较重要的步骤 ​ 当单步到这里时，这个函数里面进行了很多计算，并且在这个函数里面有试用剩余天数的提醒，并且还有激活成功的字样，如下图： ​ 单步调下来发现在上图的4043E0处，直接跳过register version字样，这样修改jnz可能会直接激活成功，修改jnz如下图，界面显示激活成功，但是将系统时间改到30天之后，程序依旧不能运行。 ​ 查看刚刚跳转指令上面几条指令，发现比较了eax和ecx的值，而eax的值为0x96，ecx的值由0x412CB8决定，运行到这里时0x412CB8的值是0x32，并不是0x96，继续在OD的堆栈区观察值的变化，发现当程序运行到如下图地址时，0x412CB8的值发生了变化 ​ 上图指令一条条分析，只要eax值为0x96则会使je触发，但eax的值又由0x40F240决定，从而跳过mouselig.004018D0这个函数，并且412CB8的值也为0x96，使用IDA分析mouselig.004018D0这个函数，如下图，截取这个函数的一部分： ​ 可以看到这个函数是用于计算剩余天数的，所以这个函数跳过去意味着可能会跳过时间限制，查看上面提到的0x40F240地址的值 ​ 使用IDA查看之后发现这里值为0x32，将这里的二进制值改为0x96。 ​ 运行程序，发现破解成功。将程序保存为MouseLight1.exe，运行程序，将系统时间改为30天之后，发现程序依旧可以运行。但是这之前要将之前的return -7改为return 1。最终结果如下图所示：]]></content>
      <categories>
        <category>加密解密</category>
        <category>逆向破解</category>
      </categories>
      <tags>
        <tag>逆向破解</tag>
        <tag>IDA</tag>
        <tag>OllyDBG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Source Insight4093]]></title>
    <url>%2F2018%2F07%2F18%2FSource-Insight4093%2F</url>
    <content type="text"><![CDATA[SourceInsight4093：​ SourceInsight是比较强大的软件，如果觉得这个软件有用，请购买正版，发布这个纯属娱乐。 关于SourceInsight​ Source Insight不仅是一个强大的程序编辑器，而且是面向项目开发的程序编辑器和代码浏览器，它拥有内置的对C/C++, C#和Java等程序的分析。能分析源代码并在工作的同时动态维护它自己的符号数据库，并自动显示有用的上下文信息。运行截图如下图所示： ##过程 ​ 先使用查壳工具PEID查壳，然后通过试运行sourceinsight查看会提示什么，然后决定使用什么方法来破解，一般来讲，输入注册码不正确跳出提示框，这样可以通过查找字符串进而找到关键算法，通过下面尝试，这样方法确实可行，但是并不能完全破解，只能绕过一个判断。商业软件毕竟是别的软件不一样的，sourceinsight有在线检查黑名单制度，而且相较于之前版本，黑名单检测地方在不断增多，找到黑名单检测处并且一一注释才能够最终完成破解。 ###1.查壳 ​ 先用PEID查壳，发现没有加壳，但是入口地址和偏移与之后在IDA里面看到的不一样，这是win7下的ASLR技术，ASLR技术是对缓冲区溢出的安全保护技术，对堆栈、共享库等映射随机化，这样提高安全，但是不利于我们分析，IDA动态调试的时候不能返回，相对OD显得不那么方便，但是IDA反汇编出来的地址就是没有随机化的地址，是最原始程序的地址，而OD是随机化的，所以通过参考IDA，并且尝试关闭win7下的ASLR服务，这样就可以使用OD进行动态调试，使用IDA反汇编查看源码，这样可以快随方便的找到关键判断，加速破解进度。下图为查壳结果：无壳 ###2.关闭ASLR ​ 如果想使用OD动态调试，那么必须要关闭ASLR服务，因为每次调试的断点，注释会随着动态地址变化而消逝，所以必须要关闭ASLR服务。下图为没关闭ASLR服务之前的OD加载地址与IDA加载地址效果图：可以明显看到OD的地址漂移。 ​ 网上下载ASLR关闭工具进行关闭是不行的，后来Google上找到一篇帖子，介绍了方法，通过win+R，regedit，HKEY_LOCAL_MACHINE-&gt;SYSTEM-&gt;CurrentControlSet-&gt;Control-&gt;SessionManager-&gt;Memory Management，右键，新建一个dword变量，命名为MoveImages，将其值置为0，重启电脑即可。如下图为修改注册表中的数值： ​ 关闭ASLR后效果如下图，这样可以通过IDA找到关键处，OD动态调试辅助进行破解。 ###3.运行程序寻找突破口 ​ 下图为未破解之前截图： ​ 第一个选项是导入注册码，第二选项是试用30天，第三个选项是导入license，如果不选的话，会直接退出程序。尝试输入错误的注册码看会提示是什么， ​ 跳出一串字符如上图，然后通过IDA查找字符串，Shift+F12打开字符串界面，按下ctrl+f，然后输入上面提及的字符中not correct，搜索结果如下图： ​ 第二条记录是刚刚输入不正确注册码跳出的界面的提示，双击进入，下图所示，可以看到，字符串和上面输入错的字符跳出来的提示语是一样的。可以看到第一句The serial number you entered is not correct. A serial number for下面有DATA XREF，后面跟了一个函数，鼠标放在上面会出现函数入口指令，双击进入 ​ 下图所示，双击进入的地方，这个地址就是这串字符压入栈的地方： ​ IDA最强大的一面就是反汇编，接下来就是体现其强大的一面，按F5会将这段汇编指令尽量按照源码反汇编出来，按下F5以后效果如下图所示： ​ 可以看到上面的一个关键if判断，满足条件，就会进入到下一个if判断，两个if都满足的话，说明这个序列号是3.x版本的，第二个if如果不满足，则会进入else，见下图： ​ 可以明显看到，第67行，第二个if判断没有成立进入到这里就会显示上面提到的注册不成功的提示，而sub_40A8E0这个函数就是实现显示提示的功能，IDA查看sub_40A8E0这个函数非常方便，双击这个函数就会自动跳到这个函数，如下图，想要再回到之前的函数，点击左上角返回键即可。 ​ 上面代码可以看到是输出一串字符的，结合上面截图中的代码分析，传入的参数a1是序列号错误的提示字符串，代码中有调用其他的函数，就不一一展开说明。 ​ 回到上上图中的代码中，只要代码不进入if判断，把显示提示序列号错误的字符跳过，那么很可能找到判断序列号是否正确的关键判断。（注：上上图中代码还有一部分没有截图展示出来，都是和这个if平行的判断，跳过了这个if，可以进入到下面的判断，下面判断中用到了替换查表的方法判断，表是代码中原有存在的，查看代码可以看文章末尾附录） ​ 通过上面的分析，关键call就是sub_50C8E0(&amp;MultiByteStr,dword_66BAE8 + 1544, dword_66BAE8 + 1548, dword_66BAE8 + 1540, 1)这个函数，双击这个函数进入函数主体，下图可以看到函数中所有的代码： ​ 接下来分析这段代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273int __cdecl sub_50C8E0(char *a1, int a2, int a3, int a4, int a5)//a1为输入的序列号，如果任一判断不成立return 0,那么之前的判断会直接跳到序列号失败的那个call&#123; char v5; // al@7 char v6; // al@11 char v7; // al@13 char v8; // al@21 int v10; // [sp+4h] [bp-18h]@28 char v11; // [sp+8h] [bp-14h]@28 char v12; // [sp+17h] [bp-5h]@28 _strupr(a1); if ( strlen(a1) != 19 )//看输入的序列号是否总共为19位，形式是xxxx-xxxx-xxxx-xxxx总共19位 return 0; if ( a1[4] != 45 )//看第五位是不是字串’-’,也就是判断格式 return 0; if ( a1[9] != 45 ) //看第十位是不是字串’-’,也就是判断格式 return 0; if ( a1[14] != 45 ) //看第十五位是不是字串’-’,也就是判断格式，上面三个if判断 return 0; if ( *a1 != 83 )//第一位字母不是‘‘S’’的话，return 0 return 0; if ( a5 )//函数传参进来，值应该是1 &#123; v5 = a1[6];//将序列号的第7位给到变量 if ( v5 != 82 &amp;&amp; v5 != 71 &amp;&amp; v5 != 68 &amp;&amp; v5 != 70 )//第7位如果不是‘R’，‘G’，‘D’，‘F’，其中的一个，那么就返回0，也就是第7位这里只能是‘R’，‘G’，‘D’，‘F’，其中的一位 return 0; &#125; v6 = a1[1];//把序列号的第2位给到变量 if ( v6 &lt; 48 || v6 &gt; 57 )//如果第2位不是数字则直接return 0 return 0; *(_DWORD *)a4 = v6 - 48;//第二位的十进制数给到变量a4 v7 = a1[2];//序列号的第三位给到变量 switch ( v7 ) &#123; case 84: *(_DWORD *)a3 = 1; break; case 66: *(_DWORD *)a3 = 3; break; case 83: *(_DWORD *)a3 = 0; break; default: if ( v7 != 85 ) return 0; *(_DWORD *)a3 = 0; break; &#125;//第三位的值很关键，得是B，S，T，U其中的几位 v8 = a1[3];//第四位给到变量，如果第四位是G，a2=1，如果是V，a2=2，如果不等于GV且不等于R，那么返回0 if ( v8 == 71 ) &#123; *(_DWORD *)a2 = 1; &#125; else if ( v8 == 86 ) &#123; *(_DWORD *)a2 = 2; &#125; else &#123; if ( v8 != 82 ) return 0; *(_DWORD *)a2 = 0; &#125; if ( !a5 )//如果a5=0的话，那么直接返回1 return 1; strcpy(&amp;v11, a1);,//把a1给到v11 v12 = 0; sub_50C0B0(&amp;v11, 15, &amp;unk_5F6F88, &amp;v10);//可以看到第二个参数为15，这里其实传进去的是前15位，然后来算后4位，而这个算法就是非常关键的算法 if ( *(_DWORD *)(a1 + 15) == v10 ) return 1; return 0;&#125; ​ 总结以上代码，首先是判断序列号的合法性，必须满足如下格式（其中X表示未知字符）： ​ S(0-9)(T|B|S|U)X-X(R|G|D|F)XX-XXXX-XXXX ​ 其中第二位，根据版本要求必须是4，第三位中T 表示 试用版，B表示Beta版，S表示Standard版，U未知。因此按照本软件的要求，序列号格式应该如下： ​ S4SX-X(R|G|D|F)XX-XXXX-XXXX ​ 可以看到是do-while循环四次来做的，而当中最关键的是byte_5F6E68[]这个预先存于内存中的表取值，双击byte_5F6E68[]，可以看到表中的值，下图展示了一部分当中的值， ​ 最后四个字节可以算出来，可以尝试穷举（直接遍历 byte_5F6E68[]中的字符即可），通过这样的方法来计算出最后四个字节，但是由于时间有限，没有尝试这种方法，直接利用OD单步调试算出，然后重新运行程序，输入序列号，如下图所示：call的50C0B0这个函数，计算最后四位 ​ 进入到50C0B0这个函数，如下图： ​ 过程中没有做过多的指令分析，程序运行起来，第一次输入S4SV-UFWT-ZPR6-XXXX，鼠标选中循环之外的第一条语句，如上图橙色框。选中之后直接按F4运行到这一句，然后看下面堆栈区，就计算出来最后四位，这样重新运行程序，然后就可以输入正确的序列号，跳过这一条验证， 计算结果如下图所示： ​ 图中已标出计算结果，寄存器EAX也有计算结果，寄存器EBP中存的是前15位，可以看到前十五S4SV-UFWT-ZPR6计算出来的最后四位是F336。下次输入S4SV-UFWT-ZPR6-F336即可跳过这个判断。输入序列号， ​ 过程中跳过了以上的判断，但是，没有激活成功，效果如下图所示： ​ 这时遇到瓶颈了，在很长一段时间里，无法取得进展。IDA动态调试不是很方便，所以一直使用OD进行动态调试，进行寻找突破口。在经过一段时间寻找之后，在OD动态调试到以下函数时候，下图所示： ​ 可以明显在堆栈区看到我键入的信息，并且能看到一个文件夹，但是当我打开文件夹时，里面不存在这个文件。无法找到这个文件，在经过很多次调试之后还是无果。只是键入序列号的话，无法激活，这时候，程序一直运行在一段地址之内，无法跳出，而屏幕上也一直显示正在激活请稍后， ​ 但是就像文章开头分析一样，还有可以选使用试用30天和导入license的选项，导入license是需要选择文件夹的，这是伏笔。选择试用试一下，选择试用之后，C:\ProgramData\Source Insight\4.0这个文件夹下多了一个文件，si4.lic文件，这时候打开文件分析，格式大致如下： ​ 清晰看到，之前填的用户名，组织，邮箱，时间在里面，下面signature字眼很关键，说明这里使用了数据签名，然后可能在某处存在进行核对，如果正确的话就激活成功。将系统状态还原至还未试用的版本，通过多次调试，查阅资料之后，发现程序使用的Windows Cryptography APIs进行签名：在调试的时候发现调用了这个系统API，系统API怎么计算的具体怎么计算没有跟踪。OD动态跟踪之后，系统调用API如下图所示： ​ 通过网上查阅，“签名”和“签名验证”是通过公钥体系来实现的，所以程序中一定存在公钥，在不断寻找之后，在地址0063F648处，发现了公钥，如下图所示： ​ 找到公钥之后，只要找到什么地方对公钥试用，以及签名最后在哪里比对，可能最终完成破解，继续选择键入序列号， 这时候程序依然处于上面那一段地址内循环，此时放弃了键入序列号破解程序的想法。文中一开始提到的三个方法，只剩最后一个导入license没用了，在使用试用版本发现si4.lic文件中格式之后，自己造了一个license文件，放入C:\ProgramData\SourceInsight\4.0文件夹中，然后选择导入license，如下图： ​ 选择license文件导入，导入之后，先会进入判断序列号是否正确的断点，序列号是通过之前计算出来的，所以不会有问题。如下图： ​ 在检查完序列号之后，会一一对license文件中所有值进行一一计算验证，一路继续F7F8调试，在调试很久之后，发现很关键的字眼，如下图： ​ 上图中两个Asc码很显眼，可能接下来的重要数据就在这里，继续调试。再往下发现一处正在读入license中签名的值，如下图： ​ 再往下是继续将si4中数据进行读入并进行存储，这里只截取其中两处展示，如下图： ​ 将除签名之外所有的数据读入： ​ 将signature存在堆栈： ​ 再往下调试，出现了非常非常非常重要的函数，经过对license文件的计算，这个函数的返回值决定了是否能成功激活，如下图： ​ 进入函数主体进行分析，如下图： ​ 可以明显看到导入公钥了，这里计算非常关键，此时借助IDA反汇编查看代码，分析思路然后再次回到OD去调试尝试，这样两个工具相结合加快了破解的进展。 ​ 图中展示借用公钥计算，然后返回结果，总共可以返回的结果有472、473、474、475、472、200.代码贴出如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int __cdecl sub_50C3D0(BYTE *pbData, DWORD dwDataLen, BYTE *pbSignature, DWORD dwSigLen)&#123; int result; // eax@2 BOOL v5; // esi@11 HCRYPTHASH hHash; // [sp+0h] [bp-818h]@1 HCRYPTPROV phProv; // [sp+4h] [bp-814h]@1 struct _CERT_PUBLIC_KEY_INFO *pvStructInfo; // [sp+8h] [bp-810h]@3 HCRYPTKEY phKey; // [sp+Ch] [bp-80Ch]@1 DWORD pcbBinary; // [sp+10h] [bp-808h]@1 DWORD pcbStructInfo; // [sp+14h] [bp-804h]@3 BYTE pbBinary; // [sp+18h] [bp-800h]@1 hHash = 0; phKey = 0; pcbBinary = 2048; phProv = 0; if ( CryptStringToBinaryA(pszString, 0, 0, &amp;pbBinary, &amp;pcbBinary, 0, 0) &amp;&amp; CryptDecodeObjectEx(1u, (LPCSTR)8, &amp;pbBinary, pcbBinary, 0x8000u, 0, &amp;pvStructInfo, &amp;pcbStructInfo) ) &#123; if ( CryptAcquireContextW(&amp;phProv, 0, 0, 1u, 0xF0000000) ) &#123; if ( CryptImportPublicKeyInfo(phProv, 1u, pvStructInfo, &amp;phKey) &amp;&amp; (LocalFree(pvStructInfo), CryptCreateHash(phProv, 0x8004u, 0, 0, &amp;hHash)) ) &#123; if ( CryptHashData(hHash, pbData, dwDataLen, 0) ) &#123; v5 = CryptVerifySignatureW(hHash, pbSignature, dwSigLen, phKey, 0, 0); CryptDestroyHash(hHash); CryptReleaseContext(phProv, 0); result = v5 != 0 ? 200 : 462; &#125; else &#123; result = 475; &#125; &#125; else &#123; result = 474; &#125; &#125; else &#123; result = 473; &#125; &#125; else &#123; result = 472; &#125; return result;&#125; ​ 经过多次尝试，发现只有当返回值为200（十六进制为0xC8）的时候，软件这时候被激活，但是过程想要让它直接运行到使其直接返回C8是有困难的，所以这里直接将值改为0xC8。如下图： ​ 运行结果可以看到已经激活，结果如下图： ​ 点击确定之后，在help-&gt;about Source Insight中，可以看到已经激活的信息，并且激活的信息也与license中一致。 ###4.后续 ​ 程序破解完了会有黑名单检测，如下图 ​ 上图中会在C:\Users\liyuf\AppData\Local\SourceInsight\4.0中出现一个.dat文件，这个文件记录了你是黑名单，然后再打开Source Insight会发现下图所示： ​ 细心点可以发现，这与之前键入注册码提示的错误不一样的地方是，没有下两行的选项了，为了应对黑名单检测，总共需要修改四处地方： 1) 0050E393 85C0 TEST EAX, EAX ==&gt; 0050E393 31C0 XOR EAX, EAX 2) 0050E645 85C0 TEST EAX, EAX ==&gt; 0050E645 31C0 XOR EAX, EAX 3) 0050DF68 76 69 JBE SHORT 0050DFD3 ==&gt; 0050DF68 EB 69 JMP SHORT 0050DFD3 4) 0050F1BB 85C0 TEST EAX, EAX ==&gt; 0050F1BB 31C0 XOR EAX, EAX ​ 修改完之后保存： ​ 再次打开程序，界面如下： ###附录 附上sub_50F5A0（）函数代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155int __cdecl sub_50F5A0(int a1, int a2, int a3)&#123; int result; // eax@10 int v4; // ST28_4@17 int v5; // ST2C_4@17 int v6; // ST30_4@17 int v7; // ST34_4@17 HWND v8; // esi@22 void *v9; // eax@22 void *v10; // eax@22 int v11; // [sp+0h] [bp-128h]@0 int v12; // [sp+4h] [bp-124h]@7 int v13; // [sp+8h] [bp-120h]@7 int v14; // [sp+Ch] [bp-11Ch]@7 int v15; // [sp+10h] [bp-118h]@7 int v16; // [sp+14h] [bp-114h]@7 int v17; // [sp+18h] [bp-110h]@7 int v18; // [sp+1Ch] [bp-10Ch]@7 CHAR MultiByteStr; // [sp+28h] [bp-100h]@5 if ( !a2 ) &#123; v8 = (HWND)sub_406770(a1, 30); v9 = (void *)sub_404310(); sub_41B2E0(v9, 0, (int)&amp;v12); strcpy((char *)&amp;v13, "Courier New"); v10 = (void *)sub_41B860(0, &amp;v12); dword_66BB80 = v10; if ( v10 ) SendMessageW(v8, 0x30u, (WPARAM)v10, 1); return 0; &#125; if ( a2 == 1 ) &#123; if ( dword_66BB80 ) &#123; DeleteObject(dword_66BB80); dword_66BB80 = 0; &#125; sub_4064D0(a1, 30, &amp;MultiByteStr); sub_4454A0(&amp;MultiByteStr); _strupr(&amp;MultiByteStr); sub_406300(a1, 30, &amp;MultiByteStr); return 0; &#125; if ( a2 != 2 || a3 != 1 ) return 0; sub_4064D0(a1, 30, &amp;MultiByteStr); sub_4454A0(&amp;MultiByteStr); _strupr(&amp;MultiByteStr); sub_406300(a1, 30, &amp;MultiByteStr); if ( !sub_50C8E0(&amp;MultiByteStr, dword_66BAE8 + 1544, dword_66BAE8 + 1548, dword_66BAE8 + 1540, 1) ) &#123; if ( sub_55C580(&amp;MultiByteStr) ) sub_40A8E0( "The serial number you entered is for version 3.x of Source Insight.\n" "\n" "This version requires a version 4.x serial number.", v11, v12, v13, v14, v15, v16, v17, v18); else sub_40A8E0( "The serial number you entered is not correct. A serial number for Source Insight version 4.x is required.\n" "\n" "Please check the number and re-enter it.", v11, v12, v13, v14, v15, v16, v17, v18); sub_406A30(a1, 30); sub_4046B0(); if ( ++dword_66BB84 &gt;= sub_44E310(1) + 3 ) &#123; dword_66BB84 = 0; sub_44CEB0(); Sleep(0x1B58u); sub_44CF00(); return 0; &#125; return 0; &#125; dword_66BB84 = 0; if ( *(_DWORD *)(dword_66BAE8 + 1540) != BYTE3(dword_646848) ) &#123; sub_40A8E0( "The serial number you entered is for a different version of Source Insight.\n" "\n" "This version requires a version 4.x serial number.", v11, v12, v13, v14, v15, v16, v17, v18); sub_406A30(a1, 30); sub_4046B0(); return 0; &#125; if ( *(_DWORD *)(dword_66BAE8 + 1548) == 3 ) &#123; sub_40A8E0( "The serial number cannot be used with the 'release' version of Source Insight.", v11, v12, v13, v14, v15, v16, v17, v18); sub_4046B0(); return 0; &#125; if ( !sub_50CA20(&amp;MultiByteStr) ) return 0; if ( sub_50E180(dword_66BAE8 + 1284) ) &#123; sub_412390("Upgrade License was validated: %s", dword_66BAE8 + 1284, v11, v12, v13, v14, v15, v16, v17); result = 0; &#125; else &#123; sub_40A8E0( "Sorry, but we could not validate your previous license. Please make sure you have the correct serial number for ve" "rsion 3.x.\n" "\n" "If your old version of Source Insight is running, you can see the serial number by selecting Help &gt; About Source I" "nsight. Otherwise, the serial number was typically provided in an email activation message when you purchased the old license.", v11, v12, v13, v14, v15, v16, v17, v18); sub_406A30(a1, 30); sub_4046B0(); sub_4122B0("Upgrade License could not be validated", v4, v5, v6, v7, v12, v13, v14, v15); result = 0; &#125; return result;&#125; 参考链接： https://www.52pojie.cn/thread-713308-1-4.html https://bbs.pediy.com/thread-215669-1.htm https://www.52pojie.cn/thread-580580-1-1.html]]></content>
      <categories>
        <category>加密解密</category>
        <category>逆向破解</category>
      </categories>
      <tags>
        <tag>逆向破解</tag>
        <tag>IDA</tag>
        <tag>OllyDBG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seetaface]]></title>
    <url>%2F2018%2F07%2F02%2FSeetaface%2F</url>
    <content type="text"><![CDATA[虚拟机中进行项目： 1.环境：win7 X64、vs2013、OpenCV 2.配置环境变量：安装OpenCV的过程就是解压代码到指定目录的过程，解压完毕后有vc10~12，与Visual Studio对应关系如下：vc9 Visual Studio 2010 ： vc10 Visual Studio 2012 ： vc11 Visual Studio 2013 ： vc12 Visual Studio 2015 ： vc14 Visual Studio 2017 ： vc15 右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;双击Path 添加OpenCV变量（解压的到电脑里面的路径），我的是C:\Program Files\opencv\build\x64\vc12\bin，添加，x86的也添加上 3.开始编译Detection。 3.1打开VS2013新建项目，C++的win32控制台应用程序，注意选上空项目，然后再在解决方案处右键新建项目，这次新建dll文件，同样是空项目 3.2将活动解决方案平台转化为X64平台：点击配置管理器（配图），在活动解决方案下面点击，然后新建，改为x64，点击确定，然后将debug换成release 3.3将下载的FaceDetection源码中的data，include，model，scr拷贝到目录下，其中data在SeetaFace目录下，其他三个在FaceDetection目录下 3.4添加cpp文件，右键FaceDetection下的源文件，添加scr文件下除去test文件的所有cpp文件，一共11个 3.5配置项目属性：右键FaceDetection，属性，3.5.1：VC++目录-&gt;包含目录，编辑其目录输入include（相对路径），3.5.2：选择C/C++预处理器-&gt;预处理器定义-&gt;添加”SEETA_EXPORTS和USE_OPENMP”两项，3.5.3：C/C++-&gt;语言-&gt;OpenMP支持-&gt;是 3.6右键项目生成，在SeetaFace\x64\release下面会看到dll，lib文件 4.创建测试项目 4.1创建测试项目，同样选择空项目，现将其设置为启动项 4.2把活动解决方案转化为x64平台，如果提示创建不成功就把原来的移除重新创建，重新创建可能会导致前面配置清空，如清空则重新配置。之前这些其实都不必要，只要在新建项目平台的时候把创建新的解决方案平台的√点掉就行。 4.3写入测试代码，右键FaceDetection下的源文件-&gt;添加-&gt;新建项-&gt;C++文件，复制src\test下的代码进来，此时会有很多报错，需要配置 4.4创建lib文件，在SeetaFace下创建一个lib文件夹，把上一步x64\release里面生成的lib文件复制到lib文件夹下 4.5配置属性：右键FaceDetection-&gt;属性，4.5.1：调试-&gt;命令参数-&gt;输入:“..\data\0_1_1.jpg ..\FaceDetection\model\seeta_fd_frontal_v1.0.bin” 4.5.2：VC++ 目录 -&gt; 包含目录(添加opencv\build\include路径以及FaceDetection的inculde的路径) -&gt;库目录(添加opencv\build\x64\vc12\lib路径以及SeetaFace下的lib文件夹的路径) 4.5.3：C\C++-&gt;预处理器-&gt;预处理器定义 -&gt; 添加%(PreprocessorDefinitions)、USE_OPENMP和SEETA_EXPORTS 4.5.4：链接器—&gt;输入—&gt;附加依赖项—&gt;添加opencv_highgui2411.lib、opencv_imgproc2411.lib、opencv_core2411.lib和在3.6中生成的FaceDetection.lib 4.6本地生成并运行：解决错误error LNK1112: 模块计算机类型“x64”与目标计算机类型“X86”冲突：右键FaceDetectionTest，点击属性，弹出项目属性页，链接器—-高级，配置改成所有配置，平台改为x64，目标计算机为MachineX64（/MACHINE：x64），然后右键解决方案-&gt;属性，把FaceDetectionTest平台改为x64，运行即可。 如果显示没有包含opencv_highgui2411.dll文件，则重新检查一遍配置，然后重启试试 Alignment和Identification同样也是这样，先创建dll，然后创建测试文件 … 待续 本地在桌面SeetaFace文件夹里面]]></content>
      <categories>
        <category>Windows programing</category>
        <category>FaceDetection</category>
      </categories>
      <tags>
        <tag>Seetaface</tag>
        <tag>VS2013</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian8搭建OpenVPN]]></title>
    <url>%2F2018%2F06%2F01%2FDebian8%E6%90%AD%E5%BB%BAOpenVPN%2F</url>
    <content type="text"><![CDATA[先搭建好debian8的环境，然后确保能上网 ping www.baidu.com 内网最好改为静态ip，修改静态IP方法： 第一步： vi /etc/network/interfaces auto eth0 # iface eth0 inet dhcp # 这为原来存在的注释掉，保存为下面 iface eth0 inet static ​ address xx.xx.xx.xx ​ netmask xx.xx.xx.xx ​ gateway xx.xx.xx.xx 第二步（可不配）： vi /etc/resolv.conf #修改为自己的网关 /etc/init.d/networking restart 网关可以在宿主机上面看到 服务器端搭建 查看是否有tun和iptables_net模块支持 先查看tun cat /dev/net/tun 返回的是File descriptor in bad state说明可用，No such device则需要开通tun/tap服务，可以更新系统（apt-get update &amp;&amp; apt-get dist-upgrade）之后再查看是否开启服务 再查看iptables_net apt-get install iptables 检查系统时间是否与客户机一致，不一致则调整为一致 date -R #查看时间 date -s 01/01/2000 date -s 14:00 hwclock -w #时间写入本地 正式安装OpenVPN apt-get install openvpn lzop apt-get install zip apt-get install expect 如果安装没有成功则先更新一下系统 apt-get update &amp;&amp; apt-get dist-upgrade 使用easy-rsa生成证书 默认openvpn的easy-rsa文档会放在/usr/share/easy-rsa/下，不在则检查是否安装成功，或者用locate、find命令查找一下，然后将文档复制到/etc/openvpn/下 cp -r /usr/share/easy-rsa/ /etc/openvpn/ 生成ca证书： cd /etc/openvpn/easy-rsa/ source vars #可自行编译vars文件，也可保持默认 ./clean-all ./build-ca 提示回车默认即可，y/n选择y 生成服务器端证书和密钥： ./build-key-server server #server是服务端的名字可自行设置 提示回车默认即可，y/n选择y 生成客户端证书和密钥： 这里设置的客户端名字不能和上一步服务端名字一样 ./build-key client 提示回车默认即可，y/n选择y，想要生成多个客户端的证书和米哟啊将client改成另外的名字重复操作即可，所有证书都在/etc/openvpn/easy-rsa/keys/下面保存 生成Diffie Hellman参数： 以上完成之后执行: ./build-dh keys目录下文件如下： 配置OpenVPN服务端文件 编辑/etc/openvpn/server.conf文件，没有的新建一个，加入以下内容：(最好将注释去掉) local xx.xx.xx.xx #xx.xx.xx.xx为服务器的IPport 8080 #端口，需要与客户端配置保持一致，并保证与其他软件无共用proto udp #使用协议，需要与客户端配置保持一致dev tun #也可以选择tap模式ca /etc/openvpn/easy-rsa/keys/ca.crtcert /etc/openvpn/easy-rsa/keys/server.crtkey /etc/openvpn/easy-rsa/keys/server.keydh /etc/openvpn/easy-rsa/keys/dh2048.pem #以上为认证文件的绝对路径，根据实际情况修改ifconfig-pool-persist ipp.txtserver 10.168.1.0 255.255.255.0 #给客户的分配的局域网IP段，注意不要与客户端网段冲突！push “route xx.xx.xx.xx 255.255.0.0”#xx.xx.xx.xx表示内网网段，是网段，只在连接内网是流量走vpn，客户使用外网是任然使用其自身网络流量，规则为“route内网网段 内网掩码”；若客户端希望所有的流量都通过 VPN 传输,则可以使用该语句：push “redirect-gateway”，并在客户端配置文件加上redirect-gateway；push “dhcp-option DNS 8.8.8.8” #客户端的DNS，可不设置push “dhcp-option DNS 8.8.4.4” #客户端的DNS，可不设置client-to-client;duplicate-cn #若要在多台电脑使用一个证书，请去掉前面的;keepalive 20 60comp-lzomax-clients 50persist-keypersist-tunstatus openvpn-status.loglog-append openvpn.logverb 3mute 20 设置IP转发： iptables -t nat -A POSTROUTING -s 10.168.1.0/24 -j SNAT –to-source xx.xx.xx.xx #xx.xx.xx.xx为服务器IP iptables -t nat -L 第一条命令是设置，如果知道你的路由的外网IP，那么就把前面换为外网IP添加进去 看到如下字样则转发成功： SANT all – 10.168.1.0/24 anywhere to:xx.xx.xx.xx#xx.xx.xx.xx为服务器IP 修改/etc/sysctl.conf的内容为： 这个文件进去之后全是注释，在最下面加上这几句 net.ipv4.ip_forward = 1 net.ipv4.conf.all.send_redirects = 0 net.ipv4.conf.default.send_redirects = 0 net.ipv4.conf.all.accept_redirects = 0 net.ipv4.conf.default.accept_redirects= 0 然后执行 sysctl -p 使其生效，到这里服务器端的配置都完成了 /etc/init.d/openvpn restart 上面的命令让OpenVPN重启 如果无效的话，那么重启debian 想使其开机自动运行的话还需要： 创建/root/vpn.sh 文件，加入下面的内容：（复制到VPS上时，最好把注释去掉） #!/bin/bash /etc/init.d/openvpn start #Debian下OpenVPN不用设置就可以开机自动运行，如可以自动运行就去掉这句 /sbin/iptables -t nat -A POSTROUTING -s 10.168.1.0/24 -j SNAT –to-source xx.xx.xx.xx #xx.xx.xx.xx为服务器IP，实际根据自己的服务器来做调整，这只做示例 将这一脚本写入cron执行计划，执行 crontab -e @reboot /bin/bash /root/vpn.sh &gt;/dev/null 2&gt;&amp;1 这是服务端，还有客户端，当然如果更改了上面的配置文件一定要重新导出证书放在openvpn安装目录下的config文件夹下 端口映射上面中有提服务端端口设置，设置外部端口，让其映射到内部端口（服务器端口），在xx.xx.1.1里面设置 客户端主要配置windows客户端 下载客户端，下载地址：https://openvpn.net/index.php/open-source/downloads.html翻墙的时候要开全局，不然访问页面都会很卡 下载证书，使用SourceFXPortable连接到debian8下载，SourceFXPortable下载地址：https://pan.baidu.com/s/1fA53wVXlL-SAFRvLap-Ugw 密码：ruep 证书在/etc/openvpn/easy-rsa/keys里，两个证书一个key ca.crt、client.crt、client.key放在openvpn安装目录下的config文件夹里面 创建客户端配置文件 在上面提到的config文件夹下面创建一个sunny.ovpn文件，添加以下内容： client #这个client不是自定义名称不能更改 dev tun #要与前面server.conf中的配置一致。 proto udp #要与前面server.conf中的配置一致。 remote xx.xx.xx.xx 88 #xx.xx.xx.xx为路由外网的IP，88为外部端口，端口与之前端口映射的外部端口一致，若同处内网，则ip和端口与前面的server.conf中配置一致。 resolv-retry 20 nobind persist-key persist-tun ca ca.crt #具体名称以刚下载的为准 cert client.crt #具体名称以刚下载的为准 key client.key #具体名称以刚下载的为准 ns-cert-type server /# redirect-gateway#如服务端配置为push”redirect-gateway”，则保留这行，否则请注释掉 keepalive 10 30 comp-lzo verb 3 mute 20 route-method exe route-delay2 运行OpenVPN客户端，绿色则表示连接成功，黄色就是断开连接 各种连不上以及问题参照本地vpn启动及恢复检查文档-最新.word ##文章参考： http://shit.name/openvpn-on-debian/ 以及实验室OpenVPN安装文档]]></content>
      <categories>
        <category>Linux</category>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>Debian</tag>
        <tag>OpenVPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git上传本地代码]]></title>
    <url>%2F2018%2F05%2F18%2FGit%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[步骤： 首先在GitHub上建一个仓库 本地新建一个保存代码的文件夹，在保存代码文件夹里面打开git bash 然后执行 git init 然后是添加代码，把代码复制到这个文件夹下，执行 git add .//全部添加 git add xx.cpp//一个个添加 然后执行 git commit -m “保存代码的文件夹” 关联仓库：git remote add origin https://git@github.com:Summary22/Myproject.git 上传执行 git push origin master 注意：第一次上传的是其他颜色字体]]></content>
      <categories>
        <category>git_operation</category>
      </categories>
      <tags>
        <tag>git_Push</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pdf2word]]></title>
    <url>%2F2018%2F05%2F17%2Fpdf2word%2F</url>
    <content type="text"><![CDATA[PDF2Word分析程序启动后弹出注册页面，随意输入E-mail和注册码后弹出提示错误的窗口 思路使用IDA破解，软件破解思路是查找字符，看Graph View，最后看核心判断，也可以看到核心算法，写出注册机。 过程 Shift +F12找出所有的字符串，Ctrl + F搜索错误字符串“Wrong”，（同样的Alt+t可以直接在代码段查找关键词也可以）下图中可以看到 双击“Your registration key is wrong“进入下图界面 ，图中可以看出字符串所在区域是.data段，并没有在代码段，字符串后面有注释，有写data xref，xref是交叉引用的意思，鼠标移至后面箭头会出现这个call里面具体的代码，鼠标滚轮向下滑动，会显示出更多。双击这里即可进入相应的代码段。 双击图中黄色的16F后的箭头跳转到字符串的引用位置 向上滑动一点可以看到注册成功的相关代码，当然直接搜索字符串也能找到注册成功的相关代码，如果使用的是OllyDbg，通常的做法是在注册失败的代码中打断点，回溯到判断注册是否成功的代码中去，这里使用IDA的Graph View可以加快破解速度，在代码段按空格就会切换到Graph View， 可以非常明显的看到判断注册是否成功的流程，有红色断点的框中是判断注册是否成功的函数，先调用call ds:GetDigItemTextA获取输入的注册码，再把注册码通过栈作为参数传到sub_405F60函数中去，这个函数的返回值eax就是最后的注册结果，eax= 0时注册失败，暴力破解可以直接修改eax的值为1，略。下图中，可以看到跳转的连线有红色和绿色，红色是判断失败则执行，绿色是成功执行。 可以看出sub_405F60是关键的call。 用Graphmode整体地看下sub_405F60函数，左分支返回的都是eax= 0，造成注册失败，输入的注册码只要使程序到达最右下的分支即注册成功 逐条分析指令，发现有如下几条条件限制： 判断输入的注册码长度是否为0x14，即20(d)位 atoi(code[0]) + atoi(code[1]) = 0xB (注意这里没有使用ASCII码做运算) (int)注册码的第一位+ (int)注册码的第二位= 0xB atoi(code[18]) + atoi(code[19]) = 0xD (int)注册码第19位 + (int) 注册码第20位 = 0xD atoi(code[5])+atoi(code[13]) = 0x9 code[12] = 0x56(ASCII ‘V’) code[14] = 0x33 (ASCII ‘3’) code[15] = 0x33 (ASCII ‘2’) 综上 注册码code的要求为 总长度20位 atoi(code[0]) + atoi(code[1]) =0xB （11D） atoi(code[18]) + atoi(code[19])= 0xD （13D） atoi(code[5]) + atoi(code[13])= 0x9 （9D） code[12] = ‘V’ code[14] = ‘3’ code[15] = ‘2’ 其他位随便填写 注册机以及满足以上要求的一个注册码是如下图： 破解以后的画面是下图： IDAIDA的Graph View功能十分强大，F5更是可以近似生成源码，而且动态调试的时候在程序段同样可以查看到Graph View，而且当从一个模块到另一个模块的时候，如果停在上一个模块的最后一条指令，那么接下来要执行哪一个模块，指向那一个模块的线会跳动。但是感觉IDA动态调试没有OD方便，可能是IDA用得比较少吧。。。]]></content>
      <categories>
        <category>逆向分析</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>逆向破解</tag>
        <tag>IDA</tag>
        <tag>pdf2word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[010Editor]]></title>
    <url>%2F2018%2F05%2F03%2F010Editor%2F</url>
    <content type="text"><![CDATA[010Editor破解关于软件 官网的介绍：Professional Text Editor+World’s Best Hex Editor ) 破解思路抓包分析软件在验证的时候没有发包，所以可以确定注册码一定是在本地生成，找到判断成功与否的指令，改掉jnz或者在上层调用中改返回值。此次没有编写注册机。 破解过程 先使用PEID查壳，发现无壳 用OD打开程序，F9运行起来，tools-&gt;register，会弹出一个form，然后随便输入用户名，验证码，点击确定，弹出失败的messagebox，此时F12暂停，堆栈查看 属于程序领空的一一查看，0012A380处，shawcall，会发现很多字符串，判断的地方应该就在这里，然后在这个函数的入口处下断 再次点击check license，会断在刚刚断点地方，F8单步下去，会发现有一处cam后跳过了正确的字符，修改这里，破解成功。]]></content>
      <categories>
        <category>加密解密</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Ollydbg</tag>
        <tag>逆向破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinRAR去广告]]></title>
    <url>%2F2018%2F04%2F23%2FWinRAR%E5%8E%BB%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[WinRAR去广告目标WinRAR是一款强大的压缩文件管理工具，目前最新版本为5.50版本，但是中文免费版本在每次启动时，会弹出广告页面，本次破解目标是去除广告页面。如下图： 思路官网下载软件，先使用PEID检查是否有壳，有壳的话去壳，然后通过OD进行跟踪分析，找到页面弹出的指令将其nop或者直接jmp，达到去取广告的目的。 过程 先使用PEID查壳，无壳，但无法查出是什么语言编写的程序。 F9运行后F12暂停，Alt+K查看堆栈，找最近在程序领空的调用，右键show call，查找ASC和Unicode没有发现关键字，这样只能F8单步下去，查看运行哪个call程序会运行并弹出广告，然后打断，F7单步进这个call，这样反复查看，最后找到弹出页面的call，nop或jmp这个call。如下图所示： 程序入口点： F8跳过这个call时会运行程序并且弹出广告，在这下断，Ctrl+F2重新运行，F9到这一步，F7进入 进入上面的call，F8下去，如下图注释，第一个call，弹出form，第二个call，加载form里面的内容，这里不会弹出广告 运行第一个和第二个call以后的结果： 继续F8调试，当运行完下图这个call之后，弹出了广告 查看上图指令，经过一番研究，上面一条指令je short WinRAR.0132CF78，跳过紧挨着je的call指向弹出广告的call，这里修改je指令，将其修改为直接跳过弹出广告的call，如下图所示： 然后F9运行，发现不会弹出广告，将其保存替换exe即可]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>Ollydbg</tag>
        <tag>逆向破解</tag>
        <tag>WinRAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[U盘杀毒专家]]></title>
    <url>%2F2018%2F04%2F20%2FU%E7%9B%98%E6%9D%80%E6%AF%92%E4%B8%93%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[U盘杀毒专家破解追码关于软件 U盘杀毒专家是一款国产的专业U盘病毒专杀工具，它可以检测查杀文件夹变成exe病毒，auturun病毒，vbs病毒，U盘文件夹被隐藏等1200多种U盘病毒，还可以免疫U盘，自动修复因为病毒而损坏的系统配置以及文件。另外还提供一些其他U盘辅助功能，比如U盘解锁功能，以及进程管理等。如下图，需要用一些功能的时候需要购买，目标就是破解此处并写出注册机。 破解思路官网下载软件，先使用PEID检查是否有壳，有壳的话去壳，然后通过OD、DeDe等进行跟踪分析，找到算法，最后编写出注册机。 破解过程 先使用PEID查壳，发现是UPX壳，使用UPXEasyGUI 2.0去壳，Scanner-&gt;Browse选择exe文件所在文件夹-&gt;Option&gt;Decompress-&gt;Start,如下图，完了再检测，就会发现程序已去壳。 发现是Dephi编写的程序，于是用DeDe来寻找确定按钮事件，进而寻找方法破解。打开DeDe，点击forms根据名称以及坐标寻找按钮，根据事件的名字，BuyNow事件就是立即购买按钮，双击，根据名称以及坐标，发现button14为点击立即购买以后那个确定按钮，如下图： 根据上图找到的确定按钮入口地址，在此下断，F9程序运行，点击立即购买，然后随意输入一串字符，点击确定，会断在确定按钮的入口地址，开始F7，F8，交替调试寻找： ​ 上图主模块区，最下面的指令test al，al，当F8到这里，发现执行完这一句，下一条指令跳过了很多call，很有可能是关键判断，试一下，nop掉下一句JNZ，F9运行，发现破解成功，但是并没有真正的注册，如下图，所以可以判断，这之前的call很可能是关键call，点击确定，将nop的修改回来，进入上面提及的call ​ 进入之后F8运行，当运行到下图所示时，会发现一串字符串，这串字符可以用于升级换注册码，这并不是正确的注册码，继续往下寻找 ​ 再继续往下寻找，又发现类似上图一样的一串字符，如下图： ​ 经过验证，这里的字符串就是正确注册码，但是一旦输入这个注册码，然后点击确定，就会写进注册表，点击立即购买就会一直出现您已购买，这给之后的分析造成麻烦，所以这里不输入，进入这个关键call寻找算法写出注册机，如下图，这个call里面有两个call，其他指令是赋值和对栈的操作，进入第一个call，一步一步运行会发现是生成机器码的过程，然后单步进入第二个call， ​ 如下图，算法就是在下面图上所示，通过分析，可以判断，正确的注册码是通过取出每个字符经过一定操作进行计算的，而真正的算法是：假设计算到第n个字符，用（2*n+1）+第n个字符的asc码+1，结果就是正确注册码的asc码，通过上面算法算出的asc码如果不是字母或者数字则跳过，详细注释见下图 ​ 这个for循环之后在local3里面存的就是正确注册码，所以可以肯定，这两个call肯定会成功生成正确的码，单步进入第一个call，发现里面很简单，但是进入这个call的第一句，push edx，很关键的一句话。这时候会压入上面算法计算的值，将这个数据保护起来。 ​ 单步进入，这时候，有三个call在这里，经过分析，第一个call并没有生成正确字符，第二个call里面，有着重要的信息，而此时，0012F818这个地址的值没有改变，一直关注这里的值，单步进入第二个call，指令的分析见下图。 编写注册机 上面细致分析了算法，接下来就是根据算法编写注册机，下图为注册机界面： 可以比对，生成的注册码和上面图中提及的正确注册码一致，将注册码输入，即可注册成功。再次点击立刻购买，会提示你已经注册成功，如下图：]]></content>
      <categories>
        <category>加密解密</category>
        <category>注册机</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Ollydbg</tag>
        <tag>逆向破解</tag>
        <tag>DelphiDecompiler</tag>
        <tag>Delphi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crack007]]></title>
    <url>%2F2018%2F04%2F13%2FCrack007%2F</url>
    <content type="text"><![CDATA[Crack007-aLoNg3x.2关于题目 此题和上题很相似，但是具体内部实现是不一样的，而且本题的目标是写出注册机。同样的这个程序是用Delphi写的，无壳，程序隐藏两个按钮才达到破解，首先输入用户名和序列号，点击register，如果正确，register按钮隐藏，会出现一个again按钮，两个按钮全部隐藏既破解成功，另外有个about按钮，点击会弹出四个form，只是一些说明和提醒，还有一个cancella按钮，用于将序列号清零，当你输入的序列号不为纯数字的时候会跳出提醒，当输入序列号为0时也会弹出提示框。下面为程序初始状态： 解题思路借助DelphiDecompiler找到各个事件入口地址，用OllyDBG动态调试程序，在事件入口打断点，然后单步分析指令，分析逻辑关系，找出主要算法，写出注册机。 题解过程 用DelphiDecompiler打开exe文件查看各个按钮事件的入口地址并在下地址下断，事件后就为入口地址： 单步调试，查看算法，先查看register事件，输入用户名：qwer12，序列号：123456： 由于之前在register事件入口下断，所以程序会停在register事件入口，这时单步F8向下调试， 到这里可以看到，这个je跳过了提示框以及下面三个call，说明输入符合要求。继续F8运行， 到上面一步，这个跳转跳过了隐藏register按钮和显示again的关键call，按下esc往上一步看，test里面al的值决定这个跳转，再往上看，test上一条指令，call aLoNg3x_.00442FF2，很有可能这个call里面就有关键的算法，单步F7进去查看算法， F8单步到这一步的时候，可以看到一个关键的跳转，JNZ跳过了一句赋值语句，让bl为1的赋值语句，然后继续F8，当跳出函数，回到上图test语句的时候，这时al为0 将上一步的JNZ指令nop掉，让bl直接为1，可以看到，al的值也为1，并且register按钮隐藏，again按钮显示出来，再点击一下again按钮就破解成功了，如下图： 通过上面分析可以判断，上面图中，JNZ上一步的cmp为关键判断，这条指令比较的是寄存器EBX和ECX里面的值，再往上分析，去寻找EBX和ECX的算法。重新运行一下程序，然后单步进入关键call，从建立栈帧开始单步往下分析，下图所示，通过call取出用户名长度存在EAX中，然后通过cmp判断输入用户名是否合法，这里的限制条件是用户名必须大于4位。 继续往下调试，可以看到有两个循环 这里执行的算法是： 内层循环中，开始取输入的用户名的第一个字符和最后一个字符相乘，然后再与edi相乘，结果存在edx，最后将ebx与edx相加后结果存在ebx，比如上面例子中，输入用户名为qwer12，那么第一次就是字符q的asc码与字符2的asc码相乘，然后与edi里面的值相乘，最后加上ebx里面的值结果存在ebx。 因为esi第一次赋值为1，在内存循环中不变，所以在一次外层循环中，edx始终保持不变，对于外层循环来说，外层循环一次，等于输入用户名的一个字符依次乘用户名的所有字符，并乘edi，求和之后保存在ebx。 这里执行的时候上面有指令将ebx置0，那么变量只剩下edi了，程序调试中，edi始终为0，这就导致最后结果一直为零，关键判断不相等，跳过将bl置1的指令。所以需要寻找到edi的赋值指令，往上会看到 这条指令将eax的值给了edi，而前面的语句没有提及eax，所以要回到call外面去找，重新点击register，程序断下之后寻找eax赋值指令 在关键call上一条，将地址0x445830的值赋给eax了，但是这时这地址里的值为零，这时要寻找给这个地址赋值的指令，往上可以看到一条，mov dword ptr [0x445830],eax，但是这条指令被上面判断序列号是否合法的跳转语句跳过了，再往上找不到操作这个地址的指令了，可以判断，在mov dword ptr [0x445830], eax指令上一条call指令，很有可能包含eax的算法，分析这个call，可以找出eax的值。输入一个不合要求的序列号，带字母即可，单步进入这个call，进行分析。 上图输入不是数字的序列号，顺利进入到赋值语句之前的关键call里面，图中有一条指令cmp eax，0x5，这条指令要求输入序列号必须大于五位，所以这里的cmp置Z标志位为1，跳转指令跳过了关键算法，重新输入序列号，重新进入，分析主要算法。 这里算法只有一个for循环，刚开始将序列号长度取出存在eax，并将其赋给ebx，作为控制条件，然后取出序列号的第二个字符除以0x11的余数存在edx，然后再加一，取出序列号第一个字符与edx相乘，这算一次循环，下次操作第三个字符和第二个字符，循环五次，最后的结果加上0x37B。接着分析下面算法： 计算的结果存在eax中，然后结果除以0x7148，结果存在eax，余数存在edx，然后将结果转存在ebx，最后又将ebx的值返还给eax，计算的结果暂称为因子，因子的计算解决了对图十二分析时所遇到的问题，但这里要输入不合法字符串才能计算。接下来继续分析图十分析之后的算法： 首先将计算的结果存在eax，，然后对0xA2C2A进行取余，结果存在ebx，然后用输入的序列号除0x59，商保存在ecx，输入的序列号再对0x50取余，结果加上之前的ecx，最终结果再加一，然后和ebx值相比较，如果相等，则jnz不会跳转，bl的值会等于1，这时候，再回到这个call之外，将不会再将隐藏register按钮和显示again按钮的指令跳过，会执行，也就破解成功一半，again按钮的计算方法和register按钮就算方法一样，所以只要执行一遍对register按钮的操作，again按钮也将隐藏。 编写注册机 上面细致分析了算法，接下来就是根据算法编写注册机，下图为注册机界面： 在计算注册码的时候会生成多个，所以可以随机选择。 特别说明：（1）.在计算的时候，如果用户名字符串输入过长，或者长度小于6，都是属于不合法的用户名。输入过长的话，计算的时候，因为寄存器为32位，所以结果很可能溢出造成错误。经过测试，如果输入用户名为6个纯字母，结果溢出，所以用户名最好以数字和字母配合，而长度大于6位，很大几率造成溢出，如果选取asc码值比较小的符号当中用户名的话，情况会好一些。（这些可能是程序本身造成的限制） （2）.验证注册码是否正确的步骤应该是，随机填写用户名和注册码（这个注册码一定为不合法的注册码，也就是不要全为数字，这样edi的值才不为0），点击register键，出现提示框点掉，然后用注册机生成注册码，将生成的注册码重新填入程序，点击register，这时候register会消失，然后重新做一遍上述操作，again也会被隐藏，破解成功。 下图为随机验证： 破解之后会出现Cracked by casa63. 另外补上注册不成功的截图： 补充-OllyDBG破壳用OD加载进去之后，先F8单步运行一下，然后看见右边ESP字体是红色的，右键ESP在数据窗口跟随，这时候右键左下方的地址后面的十六进制码，选择long，然后address，然后选择esp那里作为断点（硬件访问-&gt;word），（然后这种方法不可行） 另一种方法：使用UPXEasyGUI去壳，scan文件夹，option一下是加壳还是脱壳，然后点击开始，再用pied查壳发现没壳了]]></content>
      <categories>
        <category>加密解密</category>
        <category>注册机</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Ollydbg</tag>
        <tag>逆向破解</tag>
        <tag>DelphiDecompiler</tag>
        <tag>Delphi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crack013]]></title>
    <url>%2F2018%2F04%2F04%2FCrack013%2F</url>
    <content type="text"><![CDATA[Crack013-badboy关于题目 通过PEID分析，此题是P-Code编码的VB程序，下图是未破解前程序所有状态。两种模式，一种是序列号，一种是名称加序列号（输入字符5个以上），输入不正确会出现Try Again字样。 解题思路如果此题采用OllyDBG动态分析，很难找到合适断点去修改指令破解。既然程序采用VB就可以使用VB.Decompiler进行静态分析并修改，达到破解的目的。 题解过程 首先使用PEID查壳，检测到是VB程序，如下图： 用VB.Decompiler加载exe文件，如下图 点击下方Combol1_Click事件进行分析，如下图 分别点击Command2和Command4进行进一步分析 根据分析，通过Disassemble找到判断语句对应的反汇编指令，在HEX Editor中搜索并进行更改，破解模式1：搜索4051DA并将1C改为1D或者将4051CA处FB 30改为FB 3D。破解模式二：搜索405815将1C改为1D或者将40580D处FB 30改为FB 3D，（部分指令含义见文章末尾附录），如下图： 破解成功截图 另外的方法：用OllyDBG来分析的话，可以找到正确密码，但是很难将其破解。简单介绍这种思路： 用OllyDBG将exe运行，选择断点：BreakPoint-&gt;VB APIs-&gt;Comaparision-&gt;_vbaStrcomp，然后F9运行程序，输入序列号：123456，点击try，F9运行程序会中断，看主模块的堆栈区，会显示出来正确的答案：7718158。 同理，名称加序列号模式也会出现正确序列号： 这时候名称不变再输入一次序列号57572-444610就会成功。 程序有一点特殊的地方：输入正确的序列号点try，显示”Congratulation !”和“OK”按钮，点OK按钮后，回到序列号页，又输入刚刚正确的的序列号，再次点try会显示”Try Again!”，这是因为在第一次注册成功的时候，根据上面分析Label3.caption被赋值：“Congratulation !”，只有再次输入Congratulation !才能再次成功，不再会跳出Try Again! 附录 跳转指令： Branch-无条件跳转-1E BranchT-栈顶数据为真则跳转-1D BranchF-栈顶数据为假则跳转-1C 比较指令： EqVarBool-比较变量相等：FB 33 NeVarBool-比较变量不相等：FB 40 EqStr-比较字符串相等：FB 30 NeStr-比较字符串不相等：FB 3D Lt-判断是否小于 Gt-判断是否大于 补充 这里补充一下栈帧的概念，栈帧是用来实现过程/函数调用一种数据结构（就是栈），也就是记录每次函数调用的相关信息的记录单元。这个参考网址里面的内容很经典 关键跳转前面一般都是关键call，所以要写注册机的话，往这里分析 idiv是有符号除法，影响的标志位有A,C,O,P,S,Z，32位中，隐含的除数有EDX和EAX，商存在EAX，余数存在EDX CDQ：这个指令把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上。 它大多出现在除法运算之前。它实际的作用只是把EDX的所有位都设成EAX最高位的值。也就是说，当EAX &lt;80000000, EDX 为00000000；当EAX &gt;= 80000000， EDX 则为FFFFFFFF。 标志位补充： O:Overflow，溢出标志 S:Sign，符号标志，结果为负置1 Z C:Carry Flag，进位 A：Auxiliary carry Flag，辅助进位标志，记录运算时第3位（半个字节）产生的进位，有进位为1 P：Parity，奇偶标志 D：Direction，方向标志 I：Interrupt，中断标志 T：Trap，陷阱标志 一些汇编指令 shl，逻辑左移位，最后移出的一位写入cf中，最低位用0补充]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>Ollydbg</tag>
        <tag>逆向破解</tag>
        <tag>Crack</tag>
        <tag>Badboy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crack001]]></title>
    <url>%2F2018%2F04%2F02%2FCrack001%2F</url>
    <content type="text"><![CDATA[Crack001-Acid_burn关于题目 所用工具为OllyDBG，开始想用IDA，但是发现并不适合动态调试（也许将来打脸）。 题目中需要破解的是两个序列号，一个是一串字符，一个是两串，一串字符的往往是硬编码在程序内部，而两串的可以通过一定计算设计得复杂一点，通过研读指令才能破解。注册机需要完全理解汇编指令才能编写，注册机晚些在补。（截图之后再补2018.4.2） 破解过程 先用ODBG把程序运行起来，通过F8找到第一个弹框所调用的指令，然后F7单步进去，Ctrl+F8进一步定位弹框的位置，这一题，刚开始的弹框可有可无，可以迅速点击确定，然后继续点击Ctrl+F8继续运行，直到弹出下一个Form，这时候选择一个串那个，点进去，随便输一串，然后点击check，这时候，之前标记的断点起到作用了，当你看到call jmp User32.messagebox的时候，看主模块的堆栈区，找到离他最近的一个返回，右键进入反汇编，然后你会看到略微熟悉的UnIcode编码提醒，最后找到push ebp mov ebp esp，这两条指令，这两条指令是建立栈帧，然后往下寻找，找到JNZ，右键二进制，nop填充，这就破解完了，同理，两串的也是这样破解，但是这样破解唯一一点不好的地方就是不管你输什么进去都能进入，最好的方法是写注册机，这样会强大很多，这个后续一定会补上，截图后面也会补上。 这里还有第二种方法，比上面方法简单一些，我选用上面方法是因为根据参考网址 ，我的显示不了低地址的messagebox，无法去查找返回地址，然后我重新在虚拟机装了win7，这时候可以看见了，直接运行到弹出出错的form，然后去查找低地址的messagebox，右键查看调用，在这个call打断，然后继续点击check，这时候会停在断点，然后在主模块区的堆栈区找到第一条返回语句，然后右键查看反汇编，进去找一条JNZ的汇编语句，这时候看左边的实线，会看见跳转到sorry..的Unicode，Unicode语句在右边查看，将这句nop填充即可。 一点知识题目相关 发现问题：当点击左边两串，先输入一些字符，破解会失败，比如第一行输入123，第二行输入qwe，注册不会成功，这是因为程序本身在设计的时候就不允许输入字符少于三位。 汇编指令 JE，JNE，JNZ和JZ的区别，JE（jump equal）相等则跳转，JNE（jump not equal）不相等则跳转，JNZ结果不为零则跳转，JZ零标志为1就跳转。 [test和cmp的区别][https://blog.csdn.net/thanklife/article/details/11067731] 给出VB反汇编参考 总结 选择破解完01的时候，第二个选择破解09，当面对的是跳出成功和失败的页面的时候，往往可以通过先OD打开程序，先运行到密码输入错误界面，然后alt+k查看堆栈，找到massagebox查看调用，然后寻找跳转成功和失败的指令，nop掉失败的指令就爆破成功，随后的13题会单独写一篇 再来说08,08破解的方法和09很相似，有两种方法可选，第一是和09一样，运行程序直至出错，回到OD，按F12，然后去alt+K去堆栈看messageBox，查看调用（show call），然后在主模块的堆栈区，这时候一定要看提示的Unicode语句在主模块堆栈地址是否在程序领空，如果在领空的话，离他最近return右键看反汇编，上下翻动看到成功和失败的Unicode，然后查找跳转到失败的je，jNz等语句，让NOP掉这条指令就爆了，第二种方法，由于程序是VB，所以可以利用其API，BreakPoint -&gt;VB APIs-&gt;Comaparison-&gt;选上一切可疑的比如_vbaStrCmp,_vbaStrComp,_vbaVarCmpEq，然后点击确定的时候会中断，上下翻看程序是否有成功或者失败的提示，然后找到跳转NOP，这时候也可以看断点处是否在程序领空，如果在的话很可能就是那里。这种方法要看编译器 用VB.D…反编译出来的地址和OD里面一模一样，利用这个特性，其实可以把11题破了，但是要写出注册机很难，11题根据VB反编译器分析之后，可以Ctrl+G直接去含有判断的地方把跳过显示REGISTRIERT的跳转指令nop掉就可以，而且查找字符，无论是Unicode还是ASCII，都需要在程序的领空才能查到程序相关的字符，在超过程序领空的查不到 在这之后由看了04,04爆破可以在加载程序完之后选择查看asc码，看到恭喜注册成功双击进去，然后这里有一点小坑，上面的jnz指令，如果不点击程序图片的框的话，是不会运行到这里的，可以在这里下断试，把跳过成功这句jnz nop掉就可以，有时候会出现一直搜索不到的情况，那就先运行程序，F12暂停，alt+k查看堆栈，找到程序领空，show produce然后再查找就可以了 一般程序会从低地址开始加载，如果一开始运行程序的时候从F…开始的，那就是估计程序有那么一点毛病，我之前是在用OD加载之前运行了一下看，然后就从F..开始加载了，所以…讲不清 第五个，暴力破解，大概步骤是这样的，首先运行程序然后F9让其运行，然后F12中断，这时候alt+K，看到这里这个调用是在程序领空的，右键跟进去，进到主模块，右键查看ASC码，寻找“注册了”的字样，双击进去，把跳过这句话的指令全部nop，实际上只要nop第一个je和接下来的两个jnz就行，但是这个程序改了之后保存不下来，不知道为何，据说是有壳。]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>Ollydbg</tag>
        <tag>逆向破解</tag>
        <tag>Crack</tag>
        <tag>反汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密与解密学习]]></title>
    <url>%2F2018%2F03%2F30%2F%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Crack工具Ollydbg快捷键 F7-单步调试，如果遇到函数调用，会进入函数主体。shift+F7-单步调试，但是遇到中断，调试器会尝试进入被调试程序指定的异常处理。Ctrl+F7-自动步入，断点，异常会停下来，ESC可退出 F8-单步调试，遇到调用会一次执行完这个函数，shift和Ctrl和F7一样 F4-运行到选定位置，也就是运行到光标所在的位置。 Ctrl+F9-运行到return返回。 Alt+F9-执行到用户代码，也就是程序领空。 F9-让程序继续执行，shift和Ctrl和F7一样，alt+F9-执行直到返回用户代码段 Ctrl+F11-Run跟踪步入 F12 - 停止程序执行，同时暂停被调试程序的所有线程。 Ctrl+F12 - Run跟踪步过，一条一条执行命令，但是不进入子函数调用，并把寄存器的信息加入到Run跟踪的存储数据中。Run跟踪不会同步更新CPU窗口。 Alt+B - 显示断点窗口。在这个窗口中，可以编辑、删除、或跟进到断点处。 Alt+C - 显示CPU窗口。 Alt+E - 显示模块列表［list of modules］。 Alt+K - 显示调用栈［Call stack］窗口。 Alt+L - 显示日志窗口。 Alt+M - 显示内存窗口。 Alt+O - 显示选项对话框［Options dialog］ Ctrl+P - 显示补丁窗口。 Ctrl+T - 打开Run跟踪 对话框 Alt+X - 关闭 OllyDbg。 Ctrl+E -以二进制（十六进制）格式编辑所选内容。 Ctrl+F -开始命令搜索。 Ctrl+G -转到某地址。 Ctrl+K - 查看与当前函数相关的调用树［Call tree］。在用这个功能之前，必须使用分析代码功能。 Ctrl+L - 搜索下一个，重复上一次的搜索内容。 Ctrl+N - 打开当前模块的名称（标签）列表。 Ctrl+O - 扫描object文件。扫描Object文件。该命令会显示扫描Object文件对话框，您可以在该对话框中选择Object文件或者lib文件，并扫描这个文件，试图找到在实际代码段中用到的目标模块。 Ctrl+S -命令搜索。 分号是注释 IDA 快捷键 j（jump）表示跳转 o（offset）便是偏移值 p（procedure）表示子程序，回车或双击可跳 字符上按X可以打开交叉参考窗口 M键为重命名，alt+M标记当前位置，Ctrl+M跳到标记位置，选择要跳的位置双击就过去了 U让所有代码以数据的形式显示出来，C重新分析代码 F12会出现函数执行的流程图 ，按空格可以相互之间转化 Alt+T查找字符串 XREF:交叉引用 ​ 碰到地址的时候右键选择H，就会显示在这个栈帧中实际的位置，十六进制的，双击变量，变量会调到详细的视图 ​ 图形视图 蓝色，顺序执行 绿色，条件执行（YES） 红色，条件执行（NO） 文本视图 箭头实线表示非条件跳转，虚线表示条件跳转 向下箭头加上jump表示跳转 IDC作为IDA的一个重要组成，是一种嵌入式语言，一些反汇编的任务需要IDC的协助，如对代码进行加密程序，可以用IDC先写一段解密代码，在解密后反汇编就可以得到正确的反汇编结果 IDA另一个重要特征是库文件的快速识别与鉴定。 四种区段： .text：代码段 .data：数据段 .rdata：只读数据段 .bss：未初始化数据段 这里给出一个比较好的学习网址：https://blog.csdn.net/fishmai/article/details/52398376 汇编相关寄存器 EBP是存取某个时刻的栈顶指针，ESP是一直指向栈顶的指针，以方便对栈的操作 汇编指令 sete指令，cmp eax，ecx sete cl，如果eax=ecx，那么cl为1，否则为0 ，最清楚的解释是，sete指令是当zf=1时，将cl置1，否则置0 movzx，高位全用0填充 movsx，32位，低16位的第一位为1则高16位全用1填充，为0则用0填充 JBE，前者小于等于后者跳转 杂项知识点 PE—Portable Executable可执行文件 很多工具在反汇编的时候可能无法正确区分数据和代码，有些程序就是用这个来对抗静态反汇编]]></content>
      <categories>
        <category>加密解密</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Ollydbg</tag>
        <tag>Crack</tag>
        <tag>IDA</tag>
        <tag>汇编与反汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C学习笔记]]></title>
    <url>%2F2018%2F03%2F26%2FObjective-C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Objective-C笔记 .m文件代表的是message，指的是OC的一种主要特性。 #import是让编译器在头文件中查询定义 框架是一种聚集在一个单元的部件集合，包含头文件，库，图像，声音文件等，Foundation框架的头文件Foundation.h包含一百多个文件，一旦使用#import&lt;Foundation/Foundation.h&gt;， 那么将会获得全部集合。 argc是命令行总的参数个数,argv[]是argc个参数，其中第0个参数是程序的全名，以后的参数命令行后面跟的用户输入的参数，char *argv[]是一个字符数组,其大小是int argc,主要用于命令行参数argv[]参数，数组里每个元素代表一个参数 特别的.h文件和.m文件build之前一定要将.h文件右键properties-&gt;advance下的compiler…改为objc，这在环境搭建的blog也有提到 创建类12345678910111213141516171819202122232425262728293031323334353637//头文件Fraction.h#import&lt;Foundation/Foundation.h&gt;@interface Fraction:NSObject&#123; int numerator; int denominator;//成员变量，这里是private的字段，数据存储在字段中，修改字段才修改数据。封装起来，保证数据安全。&#125;-(void) print;-(void) setNumerator:(int) n;-(void) setDenominator:(int) d;-(int) numerator;-(int) denominator;//这里是属性，有get和set方法//.m文件#import&lt;stdio.h&gt;#import&quot;Fraction.h&quot;@implementation Fraction-(void) print&#123; printf(&quot;%i/%i&quot;,numerator,denominator);&#125;-(void) setNumeration:(int) n&#123; numerator=n;&#125;...-(int) denominator&#123; return denominator;//属性中get方法，这样上面print可以访问成员变量&#125;@end//main函数中使用//头文件中要包含：Fraction.hFraction *frac=[[Fraction alloc] init];[frac print];[frac setNumeration:1];[frac release];//多个参数,-(void)setNumerator:(int) n andDeminator:(int) d; 构造子，先看一下构造函数和析构函数 的区别。1234567891011121314151617//.h里面的声明-(Fraction*) initWithNumerator:(int)n denomination:(int)d//.m具体实现方法-(Fraction*) initWithNumerator:(int)n denomination:(int)d&#123; _self=[super init]; if(_self) &#123; [_self setNumerator:n andDenomitor:d]; &#125; return _self;&#125;//if(_self)等同if(_self!=nil),nil等同于NULL，//main函数中实现Fraction *frac3 = [[Fraction alloc] initWithNumerator: 3 denominator: 10];printf( &quot;Fraction 3 is: &quot; );[frac3 print];printf( &quot;\n&quot; ); self 是指指向自己的指针 Class level access 前面带有减号(-) 的方法为实例方法，必须使用类的实例才可以调用的。对应的有+号， 代表是类的静态方法，不需要实例化即可调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ClassA.h#import &lt;Foundation/NSObject.h&gt; static int count;@interface ClassA: NSObject+(int) initCount;+(void) initialize;@end//ClassA.m#import &quot;ClassA.h&quot;@implementation ClassA-(id) init&#123;_self = [super init];count++;return _self;&#125;+(int) initCount&#123;return count;&#125;+(void) initialize&#123;count = 0;&#125;@endmain.m#import &quot;ClassA.h&quot;#import &lt;stdio.h&gt;int main( int argc, const char *argv[] )&#123;ClassA *c1 = [[ClassA alloc] init];ClassA *c2 = [[ClassA alloc] init];// print countprintf( &quot;ClassA count: %i\n&quot;, [ClassA initCount] );ClassA *c3 = [[ClassA alloc] init];// print count againprintf( &quot;ClassA count: %i\n&quot;, [ClassA initCount] );[c1 release];[c2 release];[c3 release];return 0;&#125;output:ClassA count: 2ClassA count: 3 类方法用类名访问，实例方法用示例名访问。静态方法可以直接调用,实例方法要先成生实例,通过实例调用方法，静态速度很快，但是多了会占内存。静态内存是连续的,因为是在程序开始时就生成了,而实例申请的是离散的空间,所以当然没有静态方法快，而且静态内存是有限制的，太多了程序会启动不了。 类方法可以计算一个实体被instance几次，还可以共享数据，它不需要访问或者修改某个实例的成员变量。类方法一般用于实现一些工具方法，比如对某个对象进行扩展，或者实现单例。如果需要访问或者修改某个实例的成员变量时，将该方法定义成实例方法。如果需要访问或者修改某个实例的成员变量时，将该方法定义成实例方法。 插入一点:windows要通过各种各样的句柄来标识诸如应用程序实例，窗口，图标菜单等对象。句柄的实际值对程序来讲无光紧要，这个值是用来引用相应对象的。句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。 这里留给异常继承多态以及其他实体导向功能ID类型 Objective-C有一种id的类型，操作有些像void*，不过它却严格规定只能用在实体上。Objective-C与Java、C++不一样，在调用一个实体的方法时，并不需要知道这个实体的类型。当然，这个方法一定要存在，在称为Objective-C的消息传递。这种动态连接有显而易见的好处。你不需要知道你调用的方法的那个实体是什么类型，如果这个实体对这个消息有反应，那就会调用这个方法。这也不会牵涉到一堆繁琐的类型转换，比如在Java里调用一个整形实体的.intValue()就要先转换，然后才能调用这个方法。 123id number;number=comp;[number print]; 继承 关于_self=[super init] ，下面一段代码 [super init]的作用：面向对象的体现，先利用父类的init方法为子类实例的父类部分属性初始化。在iOS下，所有的类都继承于NSObject，而NSObject的init方法很简单，就是return _self。当父类的初始化完成之后，即_self不为nil的情况下，就可以开始做子类的初始化了。 把[_self init]付给_self，防止父类release掉了self指向的空间并重新获得alloc了一块空间，如果[self init]alloc失败，则不执行if语句内容。 super作为消息接受者的实质：super并不是真正的指针，[super message]的实质是由self来接受父类的message。需要注意的是，[super message]中，message方法出现的self为[super message]语境中的self，即子类实例。 123456_self=[super init];if(_self)&#123; [_self setWidth:w height:h];&#125; return _self; 重要一点：if( self = [super init] )这是一种通常的建议写法，赋值并测零只是为了防止超类在初始化过程中发生改变，返回了不同的对象 注：所有self前面均无_，只是hexo的时候会报错，所以选择加上]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>languish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下搭建OC环境]]></title>
    <url>%2F2018%2F03%2F26%2FWindows%E4%B8%8B%E6%90%AD%E5%BB%BAOC%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装Objective-C编译器需安装文件地址：链接 ，密码是：lm8y 先安装OC的编译器，这里使用的是GNUstep，安装次序为：gnustep-msys-system、gnustep-core、gnustep-devel，我安装再d盘，下面路径皆以d盘开始 接着安装IDE，选择codeblocks作为IDE 配置开发环境 先进入setting-&gt;Compiler anddebugger…,进去之后选择GUN GCC Compiler，按copy按钮，将其重新命名为GUNstep MinGW Compiler，如下图： 这里一定要将selected compiler选择到GUNstep MinGW Compiler，然后点击set as default。勾选如图的两个选项。 然后在compiler flags旁边的other compiler options里面添加这句话：-fconstant-string-class=NSConstantString -std=c99 在linker setting中添加两个链接，分别链接到libgnustep-base.dll.a和libobjc.dll.a，我的GUNstep是安装在D盘，所以路径依次是：D:\GNUstep\GNUstep\System\Library\Libraries\libgnustep-base.dll.a 和D:\GNUstep\GNUstep\System\Library\Libraries\libobjc.dll.a 如下图： 指定搜索目录，Search directories，这里有两处需要指定，第一是compiler，将其设置为D:\GNUstep\GNUstep\System\Library\Headers 第二处是linker，将其设置为D:\GNUstep\GNUstep\System\Library\Libraries 这两个不能写为同一个路径。如下图： 添加Objective-C文件支持类型 进入Settings-&gt;Environment…，选择Files extension handling 添加*.m。如图： 然后新建一个项目，在project-&gt;project tree-&gt;categories…下面将*.m添加到source下，一定要注意前面使用; 分号分开的，如下图： 进入Settings-&gt;Editor…，选择Syntaxhighlighting，点击Filemasks….按钮，在弹出框尾部添加*.m 到文件类型。如图： 然后点击Keywords…按钮 (紧靠Filemasks…按钮) 添加下面Objective-C的关键字到EditKeywords列表中。如图： @interface @implementation @end @class @selector @protocol @public @protected @private id BOOL YES NO SEL nil NULL self 这就大体完成了。 测试部分 测试代码如下： 123456789101112131415#import &lt;Foundation/Foundation.h&gt;int main (int argc, const char *argv[])&#123; NSAutoreleasePool *pool =[[NSAutoreleasePool alloc] init]; NSLog(@&quot;%@&quot;,@&quot;hello world&quot;); [pool drain]; return 0;&#125; 测试之前要在工程目录下新建一个.m文件，然后在编译器中右键这个文件，选择两个选项，如下图： .h文件也必须选择上面这一步，而且在options下面一个选项properties里面，必须这样选择properties-&gt;advanced-&gt;compiler-&gt;variable里面改为objc，这时候编译才能通过 #一点补充 关于代码高亮：在setting-&gt;editor里面，选择Syntax highlighting，然后选择objective c，点击filemasks…然后添加*.m，注意，后面加上，号,如下图：]]></content>
      <categories>
        <category>Stall IDE</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Windows</tag>
        <tag>GNUstep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一点makedown]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0-markdown%2F</url>
    <content type="text"><![CDATA[先写一点自己可能用得上的语法 有几个#号就是几级标题 一级二级三级四级 这是&gt;加空格 两个&gt;加空格 一个号加空格表示强调，可以在句中表示强调不过要以什么符号开始，就以什么结束，例子这个是星号*，如果回车还是一样的格式，不想这样要这个格式，那就再回车一下 回车再*号就会是空心小圆圈 一个-减号也是一个小黑点这样 像这样-–，***变成一个分隔符 链接有两种形式： 行内式：链接可以用[]加上()这样来书写，[]中间写链接内容，()中间写链接地址 ​ 我博客链接 参考式：两个[]连起来 例子:我的博客 &lt;noblestaspiration.net&gt; 自动链接 三个`这个符号是代码区，紧跟在三个符号后面的是语言类型，可以写Python或者C啊这些 1234567#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;111111&lt;&lt;endl; return 0;&#125; 两个``中间写的内容会变成其他颜色，但是第一个符号要加上空格 这就是其他颜色 插入图片是![]（）其中[]中填的是图片名称，后面写的是路径加上图片的名称，名称一定要加上类型，比如.jpg什么的，下面插一张图片 这里是内容 一对&lt;&gt;里面写blockquote class=”blockquote-center”这是搞一个像留言板下面那样的一个区域然后后面再加上一对&lt;&gt;里面写/blockquote这样就行了 另外\反斜杠可以帮助插其他符号，下面的就是前面已经加上反斜杠了 + ` * _ {} [] () # + - . ! 多级列表： 这是第一级 在上一行回车再回车之后tab再-加上空格]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>makedown</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python常用模块集锦]]></title>
    <url>%2F2018%2F03%2F12%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[Python常用模块集锦 常用模块主要分为以下几类（缺失的后续再补充）： 时间转换 时间计算 序列化和反序列化：json，pickle 编解码：unicode，base64 加解密：md5，sha1，hmac_sha1，aes 常见装饰器： 计算执行时间装饰器 缓存装饰器 错误重试装饰器 延迟装饰器 尾递归优化装饰器 ini配置文件读取 代码整合如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308#!/usr/bin/env python# -*- coding: utf-8 -*-"""Created on 9/21/17 1:46 PM@author: Chen Liang@function: python常用模块集锦，util.py"""import timeimport datetimeimport ConfigParserimport astimport sysimport jsonimport pickleimport base64import hashlibfrom Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexfrom functools import wrapsBEFORE = 1LATER = 2class CommonUtil(object): """Python通用单元：不好归类但常用的方法此处添加""" passclass TimeTransferUtil(object): """时间相关的常见转换方法""" class TimeUtil(object): """时间相关的常见计算方法""" @staticmethod def str_to_date(): passclass SerializeUtil(object): """序列化和反序列化：json, pickle""" @staticmethod def json_loads(json_str, encoding=None): try: obj = json.loads(s=json_str, encoding=encoding) return True, obj except ValueError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def json_dumps(obj): try: json_str = json.dumps(obj=obj) return True, json_str except TypeError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def pickle_loads(pickle_str): try: obj = pickle.loads(pickle_str) return True, obj except IndexError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def pickle_dumps(obj): try: pickle_str = pickle.dumps(obj) return True, pickle_str except Exception as e: return False, str(e)class CodecUtil(object): """编解码相关常见方法：base64 unicode""" @staticmethod def base64_encode(data): try: return True, base64.b64encode(data) except TypeError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def base64_decode(encoded_data): try: return True, base64.b64decode(encoded_data) except TypeError as e: return False, str(e) except Exception as e: return False, str(e) @staticmethod def to_unicode(s, encoding='utf-8'): return s if isinstance(s, unicode) else unicode(s, encoding) @staticmethod def unicode_to(unicode_s, encoding='utf-8'): return unicode_s.encode(encoding)class CryptoUtil(object): """加解密相关常见方法： md5 aes""" @staticmethod def md5(str_object): """md5""" m = hashlib.md5() m.update(str_object) return m.hexdigest() @staticmethod def aes_encrypt(s, key, salt, mode=AES.MODE_CBC): """ aes加密 :param s: 待加密字符串 :param key: 密钥 :param salt: 盐, 16bit eg. b'0000000101000000' :param mode: AES模式 :return: 加密后的字符串 """ cipher = AES.new(hashlib.md5(key).hexdigest(), mode, salt) n_text = s + ('\0' * (16 - (len(s) % 16))) return b2a_hex(cipher.encrypt(n_text)) @staticmethod def aes_decrypt(s, key, salt, mode=AES.MODE_CBC): """ aes解密 :param s: 待解密字符串 :param key: 密钥 :param salt: 盐, 16bit eg. b'0000000101000000' :param mode: AES模式 :return: 解密后的字符串 """ cipher = AES.new(hashlib.md5(key).hexdigest(), mode, salt) return cipher.decrypt(a2b_hex(s)).rstrip('\0')class TailRecurseException: """尾递归异常""" def __init__(self, args, kwargs): self.args = args self.kwargs = kwargsclass DecoratorUtil(object): """常见装饰器： 执行时间timeit，缓存cache，错误重试retry""" __cache_dict = &#123;&#125; @staticmethod def timeit(fn): """计算执行时间""" @wraps(fn) def wrap(*args, **kwargs): start = time.time() ret = fn(*args, **kwargs) end = time.time() print "@timeit: &#123;0&#125; tasks, &#123;1&#125; secs".format(fn.__name__, str(end - start)) return ret return wrap @staticmethod def __is_expired(entry, duration): """是否过期""" if duration == -1: return False return time.time() - entry['time'] &gt; duration @staticmethod def __compute_key(fn, args, kw): """序列化并求其哈希值""" key = pickle.dumps((fn.__name__, args, kw)) return hashlib.sha1(key).hexdigest() @classmethod def cache(cls, expired_time=-1): """ 缓存 :param expired_time: 过期时间，-1 表示不过期 :return: 返回缓存的结果或者计算的结果 """ def _cache(fn): @wraps(fn) def wrap(*args, **kwargs): key = cls.__compute_key(fn, args, kwargs) if key in cls.__cache_dict: if cls.__is_expired(cls.__cache_dict[key], expired_time) is False: return cls.__cache_dict[key]['value'] ret = fn(*args, **kwargs) cls.__cache_dict[key] = &#123; 'value': ret, 'time': time.time() &#125; return ret return wrap return _cache @staticmethod def retry(exceptions, retry_times=3, time_pause=3, time_offset=1): """ 错误重试 :param exceptions: 单个异常比如ValueError, 或者tuple,元组元素是异常，比如(ValueError, TypeError) :param retry_times: 重试次数 :param time_pause: 初始暂停时间 :param time_offset: 暂停时间的偏移倍数，默认不偏移 :return: 返回成功的值，或者重拾次数结束时抛出异常 """ def _retry(fn): @wraps(fn) def wrap(*args, **kwargs): retry_times_tmp, time_pause_tmp = retry_times, time_pause while retry_times_tmp &gt; 1: try: return fn(*args, **kwargs) except exceptions: time.sleep(time_pause_tmp) retry_times_tmp -= 1 time_pause_tmp *= time_offset return fn(*args, **kwargs) return wrap return _retry @staticmethod def delay(delay_time=3, mode=BEFORE): """ 延迟装饰器，支持在函数执行之前和之后加延时，如果想在前后同时加，可以使用两次装饰。 time.sleep只会阻塞当前线程不会阻塞整个进程，其它线程不受影响 :param delay_time: 延迟时间，是float类型 :param mode: 模式，指定是在函数执行之前加延时还是在执行之后加，值为BEFORE(1)或者LATER(2) :return: """ def _delay(fn): @wraps(fn) def wrap(*args, **kwargs): if mode == BEFORE: time.sleep(delay_time) ret = fn(*args, **kwargs) if mode == LATER: time.sleep(delay_time) return ret return wrap return _delay @staticmethod def tail_call_optimized(fn): """尾递归优化装饰器，如果被装饰函数不是尾递归函数则会报错""" @wraps(fn) def wrap(*args, **kwargs): f = sys._getframe() if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code: raise TailRecurseException(args, kwargs) else: while True: try: return fn(*args, **kwargs) except TailRecurseException as e: args = e.args kwargs = e.kwargs return wrapclass IniConfigParserUtil(object): """ini配置文件读取""" def __init__(self, *file_names): """ init :param file_names: 包含多个元素的可迭代对象 """ self.config = ConfigParser.ConfigParser() for file_name in file_names: try: self.config.readfp(open(file_name, 'rb')) break except IOError: continue else: sys.exit('All files have failed to read') def get_string(self, section, option): return self.config.get(section, option) def get_int(self, section, option): return self.config.getint(section, option) def get_float(self, section, option): return self.config.getfloat(section, option) def get_boolean(self, section, option): return self.config.getboolean(section, option) def get_list(self, section, option): return ast.literal_eval(self.config.get(section, option)) def get_dict(self, section, option): return ast.literal_eval(self.config.get(section, option)) 缺失部分后续待添加，记得填坑。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
